<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Document</title>
</head>
<body>

<h2>Páginas útiles:</h2>
    <div>
    Algunas páginas útiles para apreder Git:
    <ul>
        <li>https://www.atlassian.com/git</li>
    </ul>
    </div>

<h2>¿Qué es Git</h2>
<div>
    Es un sistema de control de versiones que nos permite rastrear o administrar los cmabios que hemos hecho en un conjunto de archivos.
</div>

<h2>¿Qué es un repositorio?</h2>
<div>
    Es el lugar donde se almacenan archivos con sus distintas versiones, rastreamos y administramos sus cambios, y compartimos esa información con otros usuarios.
    Un repositorio de acuerdo a su ubicación puede ser de dos formas:
    1. Local. Se ubicará en nuestra pc (normalmente en la pc en el que se creó) y sólo nosotros podremos acceder a él.
    2. Remoto. Se ubicará en la nube, en algún servidor como en GitHub por ejemplo, esto siginifica que podrá ser accesible por varios usuarios al mismo tiempo.
    Un repositorio local puede ser enviado a un repositorio remoto y viceversa en cualquier momento. Esta sería la mejor forma de trabajar ya que permitirá que la información esté actualizada en todo momento en todos sitios.
</div>
    
<h2>AREAS TRABAJO EN GIT</h2>
<div>
    Se refiere al estado en el que puede estar un archivo en git dentro del proceso de "llevar" ese archivo al repositorio. Son 3 áreas:
    
    1. Directorio de trabajo (Working directory): carpeta del proyecto que contiene los archivos, carpetas y el directorio .git. Estos componentes NO son parte del repositorio y NO se han añadido al área de preparación. Cuando un archivo se encuentra en esta área decimos que se encuentra en una verisón MODIFICADA (MODIFIED).
    
    -> para pasar a la siguiente área usar el comando add
    
    2. Área de preparación (Stage / Staging area / Index): es el área intermedia en la que se preparan los archivos y cambios que se van a subir al repositorio, es decir, serán incluídos en el próximo commit. Tener en cuenta que ésta no es una área definitiva, aún aquí se pueden agregar o eliminar componentes del futuro commit. Estos componentes NO son parte del repositorio. Cuando un archivo se encuentra en esta área decimos que se encuentra en una versión PREPARADA (ON STAGE).
    
    -> para pasar a la siguiente área usar el comando commit
    
    3. Repositorio (directorio .git): área final (repositorio) donde se encuentran los archivos. Es la parte que se copia cuando clonas un repositorio a tu computadora. El directorio .git contiene los metadatos, ramas y versiones del proyecto que se han ido subiendo. Cuando un archivo se encuentra en esta área decimos que se encuentra en una verisón CONFIRMADA (COMMITTED).
</div>

<h2>¿QUÉ ES UN COMMIT?</h2>
<div>
    Es un componente básico de la línea del tiempo de un proyecto de Git. Es un registro como una foto del estado de un proyecto en un momento especifico. Un commit registra los cambios al detalle en los arhivos en comparación con la versión anterior, si se modificaron, si se agregaron o quitaron, si se cambió el nombre, si se crearon, modificaron o eliminaron carpetas, etc. Todos los cambios entre un commit y otro van a estar registrados en el siguiente commit. La idea es que con los commits podamos rastrear los cambios en los proyectos, cuando se necesite incorporar una nueva versión, agragar funcionalidades, solucionar problemas o incluso regresar a una versión anterior u otras necesidades que marquen un cambio en los archivos del proyecto, se crea un commit.
    
    ## ESTRUCTURA DE UN COMMIT
    Git crea un identificador SHA (Secure Hash Algorithm) único también llamda "hash" para cada commit con el que podremos referirnos a él para ciertas operacines muy útiles. El SHA identifica los cambios realizados, dónde se realizaron los cambios y quién realizó los cambios. Con cada commit, Git también asocia una fecha automática del momento en que se crea el commit.
    Cada vez que se crea un commit se debe especificar un usuario, un correo, una descripción. El usuario y el correo normalmente ya estarán definidos con anterioridad, pero la descripción se tiene que incluir con cada commit. Esta descripción es muy imporante ya que explica de forma concisa el motivo del commit, de manera entendible para otros usuarios o para uno mismo en el futuro.    
    Para crear un commit en git hay que hacerlo con el comnado commit. Ya debe haberse creado un repositorio con el comando init y tener archivos en el área de prepación generados con el comando add.
</div>

<h2>¿Qué es una rama (branch)?</h2>
<div>
    Es una línea independiente de desarrollo en el repositorio, que evolucionará paralelamente a la rama principal y que puede o no volver a unirse a ella, pudiendo tener versiones diferentes del mismo proyecto.
    Internamente en Git, cuando se crea una rama sólo se está creado un puntero a un commit, no se cambia ningún otro aspecto en el repositorio.
    Para crear una rama o ver las que actualmente existen en el repositorio actual usar el comando branch.
    Las ramas pueden también renombrarse, incluso la rama principal puede ser renombrada en cualquier momento.
    Para cambiar de rama actual usar el comando checkout.
    Para fusionar ramas usar el comando merge.
</div>

<h2>¿Qué es el HEAD?</h2>
<div>
    El término HEAD es una referencia a un commit, un puntero que apunta a un commit específico de una rama la cual actualmente se está viendo o trabajando, es decir, nos da referencia de en qué rama estamos trabajando actualmente.
    Normalmente el HEAD apunta al último commit de la rama actual (en el que estamos trabajando), pero en cualquier momento podemos regresar a trabajar sobre un commit anterior levando el HEAD hacia ese commit, desde ese momento cualquier commit que creemos sobre el commit al que hemos regresado, deberá crearse sobre una rama nueva, ya que se supone que existe una rama que se ha estado desarrollando y está más avanzada (la rama desde la cual regresamo a un commit anterior) y esa rama no puede modificarse desde una rama anterior sin crear una nueva.
    Para moverse entre ramas o commits para desplazar el HEAD, usar el comando checkout.

</div>

<h2>¿Qué es el Detached HEAD?</h2>
<div>
    Normalmente el HEAD lo tenemos ubicado sobre (apunta a) el último commit de una rama, pero habrá veces en las que se desea regresar a commits anteriores para ver el historial del desarrollo, en este caso el HEAD no apuntará al último commit de la rama, sino que estará ubicado en cualquier commit antecesor al que lo hayamos desplazado, a esta situación se le denomina 'Detached HEAD'. Detached por que aunque estamos actualmente sobre un commit, éste al no ser último de la rama, no puede sufrir cambios, a menos que en ese momento creemos una rama nueva para guardar esos cambios. En caso de que hagamos cambios y no creemos esa nueva rama, los cambios no serán permanentes y se eliminarán tan pronto cambiemos el HEAD de posición.
    Para cambiar de posición el HEAD a un commit anterior o a otra rama, utilizar el comando checkout.
    El hecho de mover el HEAD hacia un commit antecesor (hacerle Detached HEAD), NO significa que se va a deshacer lo avanzado, no se modificará nada, es sólo que se está cambiando de posición el HEAD, simplemente se está explorando un commit antecesor.
</div>

<h2>BIFURCAR UN REPOSITORIO (Fork)</h2>
<div>
    Bifurcar es crear una copia de un repositorio remoto en tu cuenta de GitHub. Es muy útil para cuando queremos trabajar sobre un proyecto (que normalmente no nos pertenece) y no queremos (ni podemos) hacer cambios, pero sí queremos trabajar sobre él para agregarle mejoras, corregir bugs, etc., entonces lo bifurcamos (le hacemos un Fork) en nuestra cuenta, de esa manera se independiza del repositorio original y luego incluso podemos clonarlo a nuestra pc para trabajarlo en local. Este concepto de bifurcar se entrelaza con el de 'pull requests' ya que la idea es trabajar sobre la bifurcación y luego hacer el pull requests para combinar los cambios con el proyecto original.
</div>

<h2>PULL REQUESTS</h2>
<div>
    Un pull requests es una solicitud que uno hace para combinar tus cambios con el repositorio original del proyecto al cual estás contribuyendo. De esta manera es como se implementan por ejemplo nuevas características a los proyectos que son desarrolladas por otros contribuyentes. Uno hace ese cambio en la copia local y luego hace un pull requests para que los desarrolladores del proyecto original la combinen con su proyecto, desde luego, si es aceptada.
    Pull requests sería como la operación inversa de un 'fork', y están muy relacionadas por formar parte de un ciclo que tiene sentido si se trabajan juntas. Ver fork también.
</div>

<h2>Gitignore</h2>
<div>
es un archivo que deberá crearse manuealmente y situarse en la raíz del repositorio y deberá tener el nombre: .gitignore, notar el punto al inicio. Dentro de este archivo se incluirán los archivos, rutas, expresiones que no queremos tener en cuenta para los commits. Basicamente todo lo que no va a formar parte del repositorio.
Para ver el formato de este archivo ir al repositorio https://github.com/ZMv-ZMv/IGNORE
</div>

<h2>DESHACER CAMBIOS EN UN REPOSITORIO</h2>
    <div>
    <p>Referencias:</p>
    <img src="https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting" alt="">
    Para deshacer acciones en Git normalmente se usan los comandos reset, revert, checkout, rebase, restore.
    <img src="img/checkout reset revert.png" alt="">
    En el contexto de deshacer acciones estos comandos se usan para:
    <strong>ckeckout <archivo></strong>: actualiza o restaura uno o varios archivos reflejando en el área de trabajo el estado de un commit indicado que puede ser el commit actual (HEAD) o uno previo:
    1. checkout sobre el commit actual (HEAD): esta afectación sólo se producirá para archivos que estén en estado 'modificado', es decir, que NO hayan sido agregados al área de preparación y tengan cambios después del último commit. En este caso, el comando git checkout NO deshace cambios en archivos que han sido agregados al área de preparación (staging area) porque su función principal está orientada a restaurar archivos en el directorio de trabajo a su estado anterior, es decir, a un commit. Cuando un archivo está en el área de preparación, Git lo considera listo para ser confirmado, y git checkout no afecta a esos archivos. Ejemplo:
    $ git checkout archivo.txt # restaura archivo.txt al último commit siempre y cuando no haya sido agregado al área de preparación.
    2. Checkout a un Commit Anterior: cuando ejecutas git checkout <commit> (donde <commit> es un hash de un commit anterior) o git checkout HEAD~N (donde N es el número de commits a retroceder), Git cambia el HEAD a ese commit (modo detached HEAD). En este caso, se restablecerá tanto el Área de Preparación como el Directorio de Trabajo al estado de ese commit. Esto significa que todos los archivos en el área de preparación y en el directorio de trabajo se actualizarán para reflejar el estado en ese commit. Por lo tanto, si tenías cambios en el área de preparación, esos cambios se perderán, ya que el área de preparación se sincroniza con el commit al que estás haciendo checkout.
    
    <strong>reset</strong>: elimina todos los commits consecutivos hasta el commit indicado. No se recomienda para commits en repositorios remotos ya que puede eliminarse información que otro usuario sí la tenga en cuenta.
    
    <strong>revert</strong>: trae el estado de un commit previo hacia la posición final de la rama saltándose los cambios de los commits posteriores, creando nuevos commits desde esas versiones anteriores. Es el más seguro para la colaboración remota ya que no se elimina ningún commit.
    <img src="img/checkout reset revert_1.png" alt="">
    hacer una tabla con todos estos comandos y sus afectaciones 
    </div>

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

COMANDOS GIT
<div>
se debe escribir git antes de cada comando.
Estas configuraciones se guardan en el archivo C:\Users\<usuario>\.gitconfig

ls-files
    <div>
    para mostrar los archivos que existen en woriking area de la rama actual.
    </div>

config
    <div>
    para la configuración de git.
    --global
        para que las configuraciones que se hagan afecten a todo git. Se se omite, las configuraciones afectarán sólo al repositorio actual.
    init.defaultBranch
        para definir el nombre por defecto de la rama principal cuando se crea un repositorio.
        Ejemplo. Definir el nombre 'main':
        $ git config --global init.defaultBranch main
    user.name "nombre"
        para configurar el nombre del ususario de git. Normalmebte debría ser el nombre del ususario de la cuenta de github ya que este nombre es el que aparecerá en los commits que este usuario suba. Si no se especifica el argumento nombre, devuelve el nombre actual. configurado.
    user.email "correo"
        para configurar el correo del usuario de git. Normalmente debería ser el correo del usuario de la cuenta de github ya que este correo es el que aparecerá en los commits que este usuario suba. Si no se especifica el argumento correo, devuelve el correo actual.
    
    core.editor
        para asociar un editor (IDE) con Git.
        Ejemplo. Asociar Visual Studio Code con Git:
        $ git config --global core.editor "code --wait"
        --wait le dice a Git que espere hasta que el archivo se guarde, y se cierre para culminar con el commit
    alias
        para poner nombres a secuencias de comandos, algo similar a una macro. Luego para ejecutar esa macro solo hay que introducir el nombre del nuevo alias.
        Este alias se guarda en el archivo .gitconfig dentro de la carpta de usuario del sistema.
        Ejemplo 1: crear un alias de nombre 'macro'
        $ git config --global alias.macro "log --graph --decorate --all --oneline"
        $ git macro
        Ejemplo 2: crear un alias de nombre 'l1' que sirve para mostrar todos los logs en una sola línea:
        $ git config --global alias.l1 "log --all --oneline"
        $ git l1
        Ejemplo. Crear un alias para status --short:
        $ git config --global alias.ss "status --short"
        Ejemplo. Crear un alias para checkout main
        $ git config --global alias.cm "checkout main"

    --list
        para mostrar todas las configuraciones guardadas

    </div>

init
    <div>
    (Initialize) Inicializa un repositorio git vacío ¿local? en la carpeta actual. Crea la carpeta .git en la que se encuentra toda la info del repositorio. Si se borra esta carpeta el respositorio no existirá.
    .defaultBranch "nombre"
        cambia la denominación (no el nombre) de un repositorio o de todos los repositorios futuros, se decir, el nombre por defecto.
        Ejemplo. para cambiar la denominación por defecto de los respositorios futuros a "main":
        $ git config --global init.defaultBranch main
    </div>

status
    <div>
    Para verificar el estado del repositorio. Muestra la rama actual, los componentes en el área de preparación, los componentes no rastreados, etc. Tener en cuenta que este comando sólo nos muestra info de los repositorios locales. Si no se actualiza un repositorio remoto (con el comando fetch), status no nos podrá decir si nuestro repositorio local está actualizado. Si se desea verificar el estado de nuestro repositorio local respecto al remoto utilizar el comando fetch y si se desea descargar y combinar lo que hay remoto con lo que hay en local utilizar el comando pull

    --short
        para ver el estado de archivos con la info de manera acortada. El estado de los archivos se muestra con el siguiente texto incial:    
        ?? - para archivos no que están rastreando
        A - para archivos agregados al stage
        M - para archivos modificados
        D - para archivos eliminados
    
    </div>

add
    <div>
    para agregar archivos desde el directorio de trabajo hacia el área de preparación, es decir, los pasará de una versión MODIFICADA a una versión PREPARADA.
    Ejemplo. Para agregar el archivo mi-archivo.txt al área de preparación:
    $ git add mi-archivo.txt
    Se puede obviar escribir el nombre de los archivos escribiendo un punto en lugar de los archivos.
    Ejemplo. Agregar los arhchivos modificados cualesquiera q sean al stage:
    $ git add .
    </div>

rm
    <div>
    --cached
            para regresar archivos del área de preparación al área de trabajo. Estos archivos regresarán a ser parte del directorio de trabajo, es decir, el archivo volverá en una versión MODIFICADA, y el comando status lo mostrará como 'untracked'.
            Ejemplo. para remover el archivo mi-archivo.txt del área de preparación:
            $ git rm --cached mi-archivo.txt
            rm 'mi-archivo.txt'
    </div>

commit
    <div>
    Sube los cambios del área de preparación al repositorio. Ya debe haberse creado un repositorio con el comando init y tener archivos en el área de prepación generados con el comando add. Se puede incluir una descripción con el flag -m.
    Ejemplo. Crea un commit con la descripción de que se está agregando el archivo mi-archivo.txt:
    $ git commit -m "Agregar archivo: mi-archivo.txt"
    Lo ideal es trabajar en conjunto con visual studio code para trabajar la descripción de manera más interactiva y no con el flag -m. Para hacer esto sólo hay que ejecutar este comando sin argumentos ni flags: git commit y enter, esto hará que se abra VS Code con un archivo y esperará a que se guarde y se cierre para terminar con el commit. Para crear commits dentro de una rama sólo hay que estar en ella.
    
    --amend
        para modificar un commit ya realizado, modificar el mensaje, añadir o quitar archivos, etc. Hay que tener mucho cuidado con editar commits en repositorios remotos ya que ya podría haber sido descargado por otro usuario antes de hacer la modificación. Lo recomendable es hacer estas modificaciones en local. --amend espera a que se cierre el archivo de mensaje (en le editor) para terminar con la edición del commit. Este comando sirve únicamente cuando queremos modificar únicamente el commit previo inmediatamente anterior.
        Si lo único que se necesita es modificar el mensaje del commit, luego de este flag hay que agregar el flag -m seguido del nuevo mensaje:
        $ git commit --amend -m "mensaje de commit modificado"

        --no-edit
            normalmente cuando se modifica un commit se abre VS Code para editar el mensaje del commit. Este flag permite que no se abra el archivo del mesaje para modificar el mensaje, es decir, no modificaremos el mensaje del commit, sino otra cosa como por ejemplo agregar o quitar archivos del commit.

    -m
        para indicar el mensaje del commit. Tiene que ser sí o sí una única línea, pero se puede usar múltiples -m por cada línea que se desea agregar al mensaje.

    -a
        evita usar el comando add, lo que hace que se pueda realizar un commit sin estar mandando archivos al stage explicitamente ya que este flag lo hace automáticamente. No debería utilizarse este flag en commits complejos ya que podria incluir resultados inesperados.

    --allow-empty
        permite realizar commits sin cambios en los archivos. Sería como hacer un commit vacío.
        El funcionamiento normal de git no permite que se hagan commits sin cambios en los archivos, es decir, si se trata de realizar un commit 'vacío' git mostrará un mensaje alertando de esta situación y no realiza el commit, con este flag se puede saltar esta advertencia y realizar el commit.
        Ejemplo. Realizar un commit vacío con mensaje 'empty commit'
        $ git commit --allow-empty -m "empty commit"

    --allow-empty-message
        permite crear commits sin mensaje.
    </div>

log
    <div>
    Muestra el historial de commits realizados con su respectiva información descriptiva (SHA, rama, autor, correo, fecha, descripción, etc.) Este comando se puede personalizar de muchas maneras con los diferentes flags y además se pueden concatenar.

    --oneline
        para mostrar el historial de commits resumido, uno por linea.
    
    -p
        para ver las diferencias entre los commits. no entiendo bien los mensajes en este modo !!!!!!!!!!
    
    --graph
        muestra el log de commits con 'lineas' simulando la secuencia gráfica de los commits.

    --author="nombre"
        muestra los commits creados por el autor 'nombre'

    -<numero>
        muestra el número de commits últimos indicados en <numero>.
        Ejemplo. Mostrar los últimos 5 commits:
        $ git log -5
        Ejemplo. Mostrar los últimos 5 commits resumidos (cada uno en una línea):
        $ git log -5 --oneline
        Si se tiene una macro por ejemplo 'l1' (ver config alias), también funciona:
        $ git l1 -5

    <archivo>
        muestra los commits en los que <archivo> ha estado incluido.
        Ejemplo. Mostrar los commits que han incluido al archivo index.html
        $ git log index.html
        Ejemplo. Mostrar los 3 últimos commits del autor jhon sobre el archivo index.html y resumidos (en una línea cada commit):
        $ git log --oneline --author="jhon" -3 index.html

    </div>

reflog
    <div>
    para ver el registro de todo
    </div>

reset
    <div>
    para dehacer uno o varios commits (eliminarlos).
    Ejemplo. Para eliminar el último commit:
    $ git reset --soft HEAD~1
    --soft : los archivos en el directorio de trabajo nose ven afectado por la eliminación del commit, quedan tal cual están antes de eliminar el commit, quedarían en el working area, es decir, es el commit lo que desaparece, los archivos y sus cambios permanecen intactos. En Visual Studio quedarían marcados con la letra M en señal de que están modificados, ya que esa es su situación real
    ahora, el commit que los actualizó en el repositorio ya no existe por tanto son cambios pendientes de agregar al stage y luego al repositorio como si fueran archivos que nunca se subieron. Este flag no es necesario indicarlo ya que es el comportamiento por defecto. Una sitaución donde se utilizaría este comando con --soft es cuando se ha realizado un commit en una rama equivocada, en este caso se necesita mantener lo avanzado en los archivos, pero no el commit, por lo que el reset tendría sentido.
    Si hay archivos o contenido que se ha eliminado después del útlimo commit (el commit que se qiere eliminar), es decir, hay información que no se ha comiteado, una vez que se ha utilizado reset, se debe utilizar el comando 'restore' para restaurar esos cambios ya que como no se han comiteado y se ha regresado a un commit anterior a ellos donde se supone no existen, no se mostrarán como parte del woriking area.
    Si se desea eliminar también los archivos tanto como los commits se debe reemplazar este flag por el flag --hard. Tener en cuenta que esta acción es irrevocable.
    HEAD~1 : deshace un cambio desde el HEAD (desde lo último commit subido)
    Tener en cuenta que este comando puede crear commits huérfanos ya que si por ejemplo retrocedo 5 commits y existe una rama creada 3 commits atrás, esta rama no tendrá ahora un commit de inicio, no se le podrá identificar de donde vino, lo cual es problemático. Es por este motivo que este comando reset debe utilizarse con mucho cuidado o cuando se está trabajando con una sola rama o cuando se sabe bien lo que hace y las implicancias del los resultados. Un comando mucho más seguro en estos casos sería 'revert'.
    También se puede usar reset con archivos para sacarlos del área de preparación:
    $ git reset HEAD <archivo>
    Esto elimina el archivo del área de preparación, pero los cambios realizados en el archivo seguirán presentes en el directorio de trabajo (el archivo queda en estado modificado). Luego, si deseas descartar esos cambios completamente, puedes usar git checkout o git restore igual sobre el archivo.
    </div>

revert
    <div>
    Crea un nuevo commit que contiene el estado de un commit previo al actual sin borrar el actual. Aunque este nuevo commit contiene el mismo estado de los archivos que el commit al que se está refiriendo, no es el mismo, ya que incluso tiene otro hash.
    revert es por tanto, un comando que ofrece un camino más seguro a la hora de 'deshacer' cambios comparado con el comando reset por ejemplo, ya que no cambia el historial de commits que ya hayan sido subidos al repositorio.
    Para ejecutar este comando hay que agregarle el hash del commit al cual se quiere igualar el estado, una vez ejecutado, pedirá un mensaje como si se estuviera haciendo un commit común.
    Ejemplo. Revertir el estado del repositorio al commit 17a5135:
    $ git revert 17a5135
    </div>

clean
    <div>
    Eliminará archivos o carpetas que NO han sido incluidos en ningún momento en el área de preparación, es decir, son archivos del working area a los cuales nunca se les ha aplicado el comando add, por tanto no están siendo rastreados.
    Tener encuenta que si hay archivos que en algún momento anterior se han agregado al área de preparación entonces SÍ están siendo rastreados por tanto no serán afectados por este comando así tengan cambios desde el último commit que no hayan sido agregados al área de preparación, estos archivos y sus cambios no se verán afectados por este comando.
    Este comando difiere justamente en este aspecto a otros comandos como reset o checkout ya que estos últimos operan sobre archivos que ya se han agregado en algún momento al área de preparación, es decir, están siendo rastreados.
    Los efectos de este comando son irrecuperables por ello siempre se recomienda primero ejecutar este comando con el flag -n

    -n / --dry-run
        hace que el comando clean no haga efectiva ninguna acción (no elimina nada), en vez de ello listará los archivos o carpetas a eliminar sin realizar afectación alguna sobre ellos. Es una medida de seguridad antes de proceder con la eliminación efectiva de los elementos involucrados.

    -f / --force
        Es necesario siempre indicar este flag -f cuando realmente se desee que este comando tenga efecto alguno, ya que si se ejecuta el comando limpio sin flags (git clean), se mostrará un mensaje indicando que no se procederá con la ejecución del comando:
        fatal: clean.requireForce is true and -f not given: refusing to clean
        
    -d  
        para indicar a clean que también elimine directorios no rastreados ya que por /defecto clean no los incluye para ser eliminados. Este flag es siempre recomendado ya que las carpetas no rastreadas incluyen siempre archivos no rastreados. Si dentro de la carpeta hay algún archivo rastreado, entonces es suficente para considerar a la carpeta como rastreada por tanto la carpeta en sí no se verá afectada por clean. Si hay archivos no rastreados dentro de ella y se incluye este flag -d entonces estos archivos sí serán elimiandos.
    
    Todos estos flags se pueden -y se deben- combinar para tener los resultados deseados:
    $ git clean -n # muestra la lista de los archivos a ser afectados por clean
    $ git clean -dn # (o -nd) muestra la lista de archivos y carpetas que serán afectados por clean
    $ git clean -f # elimina archivos no rastreados en el directorio actual
    $ git clean -df # (o -fd) elimina archivos y carpetas no rastreados.

    </div>

branch
    <div>
    Para crear ramas nuevas en el repositorio o ver las que actualmente existen, borrar ramas.
    Ejemplo. Para ver (listar) las rammas que actualmente existen:
    $ git branch
    La rama en la que se está trabajando (actual) tiene un * al inicio
    Ejemplo. Crear una rama con el nombre version-JavaScript:
    $ git branch version-JavaScript
    Luego será necesario cambiar el HEAD hacia esa rama para trabajar sobre ella.
    ¿La rama version-JavaScript será creada sobre el último commit? ¿Qué pasa con los posibles avances o cambios que se hayan hecho luego del último commit?
    
    -m
        para cambiar el nombre de una rama. hay 2 formas de cambiar el nombre a una rama:
        1° Indicando sólo el nuevo nombre. De esta forma necesario que la rama a la que se desea cambiar nombre sea la rama actual.
        Ejemplo. Cambiar de nombre a la rama actual a "version-js":
        $ git branch -m version-js
        2° Indicando el nombre antiguo y el nuevo nombre de la rama a cambiar. De esta forma no es necesario estar en la rama a la que renombrar.
        Ejemplo. Cambiar el nombre de la rama "version-JavaScript" a "version-js":
        $ git branch -m version-JavaScript version-js
    -d / -D
        Para borrar una rama. Esto aplica para repositorios locales, no en las ramas que ya están publicadas en Github. Si la eliminación fue exitosa, Git muestra un mensaje confirmando la eliminación de la rama. La rama main (o principal) no se puede eliminar, tampoco se puede borrar la rama actual, debemos estar en otra rama para poder borrarla.
        Ejemplo. Borrar la rama "version-py":
        $ git branch -d version-py
        Esta eliminación de ramas no es definitiva, se puede recuperar la información. 
        Cuando se usa -D funciona igual excepto que la eliminación es definitiva, no se puede recuperar nada de lo eliminado.
    
    -a / --all
        visualiza todas las ramas disponibles en el repositorio incluidas las ramas remotas las cuales empiezan con 'remotes/origin' para denotar su estado remoto e indicar su presencia en un serivdor remoto:
        $ git branch -a
        * main
        remotes/origin/HEAD -> origin/main
        remotes/origin/feature-x
        remotes/origin/feature-y
        remotes/origin/release-1.0
        Este comando es muy importante dado que si se desea ser parte de un proyecto, el chequeo de las ramas siempre debe ser el primer paso.
    </div>

checkout
    <div>
    para cambiar de rama actual (puede ser una versión remota incluso), o regresar a una  versión de commit anterior, o para crear una nueva rama y cambiar a esa rama como actual, o para revertir los cambios de un archivo ...
    checkout puede operar sobre archivos, commits y ramas.
    Para cambiar de rama (funcionaría igual que el comando switch) sólo hay que indicar el nombre de la rama
    Ejemplo. Cambiar a la rama version-JavaScript:
    $ git checkout version-JavaScript
    Cuando se ejecuta este comando, Git muestra el mensaje: Switched to branch ... indicando el cambio a la rama indicada.
    Para cambiar de commit sólo hay que indicar el hash del commit en cuestión
    Ejmplo. Cambiar al commit cd1aff7
    $ git checkout cd1aff7
    Si se desea regresar un número específico de commits desde el HEAD o desde una rama (el último commit de ella) se debe indicar la cantidad de commits precedido del símbolo ~
    Ejemplo. Regresar 2 commits desde el HEAD:
    $ git checkout HEAD~2
    Ejemplo. Regresar 3 commits desde la rama 'desarrollo' (desde el último commit de esta rama):
    $ git checkout desarrollo~3
    
    -b
        crea una rama nueva y mover el HEAD hacia esa nueva rama.
        Ejemplo. Crear y cambiar a una rama llamada version-Python
        $ git checkout -b version-Python
    
    origin/main
        Cambia al repositorio REMOTO origin y a su rama main pero para trabajar de manera local. En este caso se muestra un msg que se puede hacer cambios en local que no van a modificar la información en el remoto. Es muy útil ya que si se trabaja con VS Code, se puede los cambios realizados en el repositorio retomo pero en la máquina local.
        Para que funcione adecuadamente, es necesario antes haber hecho un 'fetch' ya que sino la máquina local no sabrá qué cambios existen en el repositorio remoto, y si luego se necesita regresar a una rama local, main por ejemplo, se ejecuta el comando git switch main.
    <nombre de archivo> o . (punto)
        Se puede usar checkout con el nombre de un archivo para deshacer los cambios que se ha hecho en ese archivo. Esto revertirá el archivo a la versión HEAD.
        Ejemplo. Eliminar (revertir) los cambios realizados desde el último commit en el archivo index.html
        $ git checkout index.html
        Updated 1 path from index
        Si se tiene varios archivos a los que se requiere deshacer los cambios, al igual que con el comando add, se puede usar un punto ( . ) en vez de los nombres de los archivos:
        $ git checkout .
        Updated n paths from the index
    <hash>
        regresa a un commit anterior, para ello hay q indicar el hash del commit al que se desea regresar o parte del hash.
        Ejemplo. Ir al commit con el hash cd5f8b9:
        $ git checkout cd5f8b9
        En este momento, git informa de la situación en la que se ha entrado (en modo detached HEAD, es decir, el HEAD no está apuntando al último commit de una rama), por lo tanto, podrás hacer los cambios que quieras sin que haya problema con las ramas anteriormente establecidas en el git checkout. Ahora, si en este momento quieres deshacer los cambios que has realizado, podrás utilizar la instrucción git switch – y, si quieres guardar los cambios que hayas hecho, puedes introducir la instrucción git switch -c <new-branch-name>.
        Notar que con este comando, si hay cambios que NO se han agregado a un repositorio, estos cambios pueden perderse (pueden ser sobreesctitos por el checkout). Git informa de esta situación en vez de ejecutar el comando. El mensaje que muestra es como este:
        $ git checkout cd5f8b9
        error: Your local changes to the following files would be overwritten by checkout:
            index.html
        Please commit your changes or stash them before you switch branches.
        Aborting
        Será necesario entonces realizar un commit para que todos nuestros cambios estén seguros
    </div>

restore        
    <div>
    devuelve un archivo al estado de un commit previo el cual puede ser el más reciente o algun otro, también sirve para remover archivos del área de preparación.
    IMPORTANTE: En el caso de ejecutar este comando desde el último commit de una rama y además se tiene avanzado cambios:
    1. que se han agregado al stage: los cambios se mantendrán en el archivo y éste en un estado 'preparado', es como si no hiciera nada, por tanto no tiene mucho sentido usar este comando sobre archivos agregados al stage.
    2. que No se han agregado al stage: se perderán definitivamente estos últimos cambios y peor aún, los efectos de este comando no se pueden deshacer ya que los cambios, se supone, nunca han sido comiteados ni agregados al stage por tanto no han sido versionados ni guardados, por tanto se perderán definitivamente.
    Ejemplo. Restaurar el archivo 'myfile.txt' a su versión del último commit (los cambios no se han agregado al stage):
    $ git restore myfile
    En este caso funciona igual que el comando checkout: $ git checkout myfile
    Ejemplo. Restaurar todos los archivos a la versión del commit actual (donde está el HEAD, y no se ha agregado nada al stage):
    $ git restore . 
    En este caso funciona igual que el comando checkout: $ git checkout .
    Tecnicamente hablando, restore devolverá el archivo a la versión HEAD, la cual tipicamente apunta al último commit de la rama, pero debido a que se puede apuntar el HEAD a cualquier commit, podemos restaurar un archivo a cualquier commit previo, dándonos mucha flexibilidad a la hora de querer restaurar un archivo a cualquier estado. 
    En caso se desee restaurar archivos desde el área de preparación, este comando también sirve para remover archivos del área de preparación. En este caso los cambios que se hicieron al archivo para agregarlo al área de preparación se mantendrán y pasarán a estar en estado modificado. Se puede usar checkout, reset o el mismo restore sobre el archivo en este momento si se desea eliminar totalmente los cambios con respecto al commit (git checkout archivo, git restore archivo).
    Ejemplo. Remover el archivo file.txt del área de stage:
    $ git restore --staged file.txt
    Tener en cuenta que este comando NO desplaza el HEAD a otra ubicación como lo hace el comando checkout, sino que un archivo es llevado a una versión anterior, el HEAD sigue estando donde estaba antes de ejecutar este comando.

    --source
        Para restaurar un archivo a un commit antecesor (más antiguo) al actual. Este commit antecesor se puede espeficar de dos maneras:
        1. indicando el número de hash.
        Ejemplo. Restaurar la rama al commit 7ef42e1 (notar el punto al final):
        $ git restore --source 7ef42e1 .
        2. indicando el número de commits hacia atrás desde el HEAD actual, el commit actual no cuenta (sería como el 0), se empieza a contar 1 desde el commit anterior. Si en ese momento se desea regresar a la versión del HEAD hay que indicar 0 como número de commits hacia atrás.
        Ejemplo. Restaurar el archivo 'file.txt' hacia 3 commits previos al presente HEAD:
        $ git restore --source HEAD~3 file.txt
        Ejemplo. Restaurar a la versión del HEAD (commit 0) el archivo file.txt
        & git restore --source HEAD~0 file.txt
    
    </div>

rebase
    <div>
    para modificar uno o varios commits previos, no consecutivos.
    </div>

merge
    <div>
    para fusionar ramas. Se debe estar en la rama que recibirá la fusión. Notar que mientras se está haciendo la fusión, el mensaje de Git sobre la rama actual muestra también la palabra MERGING: (main|MERGING)
    Ejemplo. Fusionar la rama "version-js" con la rama actual:
    $ git merge version-js
    
    <h3>fast-forward merge</h3>
    Es la forma más simple de fusionar ramas, se produce cuando por ejemplo sobre la rama main, se ha creado otra rama por ejemplo llamada 'version02', se ha avanzado algunos commits sobre esta última rama mientras que no se ha avanzado nada sobre la rama main, en este caso una fusión con la rama main será muy simple ya que la fusión sólo se trata de acutalizar main con los commits avanzados en la rama 'version02'. 
    Esta forma de unir ramas no genera nuevos commits sino que trae los commits de la rama que se quiere unir (en este caso version02), sobre la rama a la que se desea unir (en este caso main), lo único que sucede es que todo el historial de commits de version02 son ahora parte de main y el HEAD de la rama main se mueve al último commit de la rama vesion02 que ahora pertenece a la rama main.
    En estos casos git nos indica con un mensaje este tipo de merge que estamos realizando, por ejemplo nos mostraría un mensaje así:
    Updating 9cd41ce..f0f439c
    Fast-forward
    myfile.txt | 4 +++-
    1 file changed, 3 insertions(+), 1 deletion(-)
    
    <h3>Recursive merge o ort??????</h3>
    Este método se realiza normalmente cuando un merge genera conflictos en la unión de las ramas. Aquí es necesario primero resolver los conflictos y luego finalizar el merge con un commit en la rama actual. En caso que no hayan confictos igual se puede forzar este método con el flag --no-ff, Git genera automáticamente el commit de unión en la rama actual.

    --ff
    --no-ff
        Se refieren al modo 'fast-forward'. El modo --ff es el activo por defecto, es decir si se puede realizar un merge con fast-forward automáticamente, git lo realizará, trayendo el historial de commits de la rama a unir hacia la rama actual y ubicando el HEAD en el último commit todo esto sin realizar ningún commit extra a los ya existentes en cada rama. Si se indica --no-ff, aunque sea posible realizar un fast-forward, no se realizará, en este caso ser realizará un merge tipo 'ort' que sí generará un commit automáticamente.

    

    --squash
        Une el último commit de la rama que desea traer sobre la rama actual, el resto de commits de la rama que se desea traer no se tienen en cuenta. Este flag no genera nuevos commits pero sí será necesario luego crear uno para terminar con el merge ya que la información de ese último commit es traída sólo como cambios agregados al área de prepación de la rama actual.
    
    Cuando hay conflictos en una unión primero se deben resolver los conflictos, luego utilizar --continue, luego add para llevar los cambios a stage y luego un commit. Ese es el proceso para terminar con un merge con conflictos. Sino, se puede usar --abort para descartar el merge.
    --continue
        Cuando una fusión de ramas tiene conflictos, primero hay que solucionar esos conflictos y luego continuar el proceso de fusión con este comando. Cuamdo se ejecuta este comando los conflictos deben estar solucionados ya que serán subidos al repositorio como un nuevo commit, en VS Code se abre una pestaña nueva esperando confirmar el mensaje de descripción y cerrar el archivo para terminar con la fusión y el commit automático. Al terminar la fusión Git muestra un msg indicando lo correspondiente.
        En el siguiente texto se ha unido la rama 'version-js' a la rama main:
        HP@HPV MINGW64 ~/ruta-reposistorio (main|MERGING)
        $ git merge --continue
        [main 34fd113] Merge branch 'version-js'
    
    --abort
        resetea la sitaución del merge, devolviendo a estao previo antes del merge / pull
    </div>

clone   
    <div>
    Crea una copia local de un repositorio remoto. Este repositorio remoto está alojado en GitHub y ahí hay que obtener la dirección HTTPS de clonación del repositorio para agregarla como argumento a este comando. Hay que tener en cuenta que git crea el repositorio en la carpeta que actualmente se está trabajando, por tanto ante de ejecutar este comando hay que asegurarse estar en la carpeta adecuada. Git mostrará unos mensajes del proceso indicando que el proceso ha sido realizado al 100%
    Ejemplo. Clonar el repositorio de GitHub 'nuevo-proyecto':
    $ git clone https://github.com/usuario/nuevo-proyecto.git
    En este caso la dirección htts ha sido obtenida del repositorio en la web de GitHub.
    Pero ocurre algo al querer enviar los cambios de vuelta al repositorio remoto, en este caso solo hemos hecho una copia en local. Si intentamos hacer git push tendremos un error ya que no hemos definido ningún origen remoto para este directorio. Para guardar en forma remota (usando GitHub) debemos crear un repositorio, conectarlo a nuestra carpeta local con 'git remote add origin ruta' y de esa forma estaremos habilitados para guardar los cambios en remoto.
    Notar que 'clone' sólo hace un clon de la rama principal del repositorio remoto y el resto de ramas no se clonan al local.
    Para clonar un repositorio con todas sus ramas:
        https://www.baeldung.com/ops/git-clone-remote-branches
        https://www.geeksforgeeks.org/how-to-clone-all-remote-branches-in-git/
    Para ver las ramas remotas (que existen en el repositorio remoto en GitHub) ejecutar 'git branch -a'.
    </div>

remote
    <div>
    Crea, ve y elimina conexiones a otros repositorios que más que links directos son como bookmarks.
    Para ver los repositorios remotos que actualmente tienen conexión con la pc local o para establecer esa conexión con los repositorios remotos, estas conexiones se realiza a través de la URL del repositorio, y para no estar tecleando siempre esa URL se puede poner un nombre a esa conexión, normalmente la primera conxión en una sesión de trabajo se le suele llamar por convención 'origin', las siguientes conexiones con otros repositorios en la misma sesión de trabajo deberán tener otros nombres. También sirve para renombrar y eliminar conexiones con repositorios remotos.
    Si se ha clonado un repositorio se debería ver al menos 'origin' que es el nombre que le da GitHub por defecto al servidor del que has clonado, además de la URL que GitHub le da al repositorio.
    El nombre que se le da a una conexión NO es el nombre del repositorio real cuando se creó y no lo sustiruirá, es sólo un nombre temporal para trabajar con el repositorio local y remotamente a la vez.
    Una vez que se establece una conexión con un repositorio remoto, se puede utilizar por ejemplo el comando 'push' para subir nuestros cambios al repositorio remoto o 'pull' para bajar cambios a nuestra pc.
    Si no hay repositorios remotos configurados, este comando no mostrará nada.
    Ejemplo. Mostrar las conextiones que actualmente se tienen configuradas:
    $ git remote
    Aquí se mostrará los nombres de las conexiones que se tengan configuradas. Si no hay conexiones configuradas este comando no mostrará nada.

    También se puede agregar varios nombres a una sola conexión, es decir, se puede agregar en local una conexión llamada 'origin', otra 'personal', otra 'general', todas ellas apuntando al mismo repositorio remoto, por tanto se agregan con el comando add y la misma dirección url.

    -v
        muestra las direcciones del repositorio origen para push (enviar cambios) y fetch (visualizar cambios). Nommalmente serán la misma dirección para ambos. Este comando no muestra ninguna info si no hay respositorios conectados. Utilizar add para agregar repositorios remotos antes de utilizar este comando.
    
    add
        Añade una conexión de un repositorio remoto al repositorio local para poder actualizar cambios u otras cosas. Este comando no crea commits ni sube archivos ni hace nada de ello, Lo único que hace es crear la conexión, para ello hay que indicar un nombre para conexión y una dirección o link del repositorio remoto. La idea es añadir un repositorio y asociarlo a un nombre que luego se pueda referenciar fácilmente, normalmente este nombre es 'origin' por convención para cuando se trabaja con un solo repositorio, pero si se desea agregar más, se debe utilizar otros nombres, luego puedes usar ese nombre en línea de comandos en lugar de la dirección URL entera.
        Después de este comando se puede utilizar -v para ver las direcciones de estos remotos.
        Ejemplo. Agregar un repositorio remoto de nombre 'origin':
        $ git remote add origin https://github.com/usuario/.....git
        Ejemplo. Agregar un repositorio remoto de nombre 'opcion2':
        $ git remote add opcion2 https://github.com/usuario/.....git
    rename <oldname> <newname>
        para renombrar un repositorio remoto
    remove / rm <name> 
        para eliminar la conexion con un repositorio remoto.
    </div>

push
    <div>
    Envía los cambios realizados en un repositorio local a un repositorio remoto para que ambos tengan la misma información y estén sincronizados. Es necesario que exista una conexión entre el repositorio local y el remoto la cual se puede configurar o verificar con el comando 'remote'
    ¿push hace un commit???
    Ejemplo. Enviar datos desde un repositorio local a la rama main de un repositorio remoto:
    $ git push origin main
    Ejemplo. Enviar datos desde un repositorio local a la rama nueva-rama de un repositorio remoto:
    $ git push origin nueva-rama
    En este caso si la rama en remoto no existe, se crea automáticamente.
    
    --set-upstream / --set-upstream-to / -u <origin/branch>>
        La forma '--set-upstream' no es más soportada oficialmente, en su lugar debe usarse '--set-upstream-to'. 
        Define la rama de rastreo remota por defecto para la rama local actual (sólo desde la rama local actual). Cualquier futuro comando pull/push en la rama actual que ha sido definida con un upstream, tomará la info de la rama remota definida en <origin/branch>>, es decir que el futuro los comandos push/pull/fetch automáticamente entenderán a que rama desde la actual se requiere subir o bajar la info remotamente, git sabrá a donde quieres subir o bajar la info sólo ejecutando 'git push', o 'git pull' o 'git fetch' sin indicar nombres de ramas remotas, manteniendo una sincronización más directa.
        Si en el repositorio remoto no existe la rama que qeremos q sea upstream (la que indicamos como argumento de este comando), se creará y Git nos informará de esto con un mensaje.
        Si localmente se cambia de rama se tiene que volver a indicar un upstream para esta otra rama actual. Lo ideal es que las ramas tengan el mismo nombre local como remotamente para no confundir.
        Ejemplo. Definir en el repositorio remoto (origin) el upstream de la rama local main:
        $ git push -u origin main # este main no es la rama local sino la rama remota que recibirá los cambios de la rama main local, por eso debería tener el mismo nombre.
        Se puede lograr el mismo resultado con 'git branch --set-upstream-to' or 'git checkout --track'
    </div>

pull
    <div>
    Descarga el contenido de un repositorio remoto e inmediatamente actualiza un repositorio local para que ambos tengan la misma información si no hay conflictos. A diferencia del comando fetch, pull combina los cambios automáticamente.
    Si no hay cambios en el remoto, este comando no hace nada. No es necesario luego usar otro comando como fetch. Lo que si puede ser necesario es utiliar el comando log para ver los nuevos commits traídos a local
    Ejemplo. Para actualizar un repositorio local desde uno remoto origni (verificar este nombre con git remote -v) hacia nuestra rama main:
    $ git pull origin main
    </div>

fetch
    <div>
    Verifica si se han realizado cambios en el repositorio remoto desde la última vez que actualizaste tu respositorio local con git pull, sin combinar esos cambios con el repositorio local y nos permite ver como una vista previa de esos cambios y luego podemos elegir si queremos conbinarlos o no con el comando merge. Se diferencia del comando pull que sí combina los cambios.
    Ejemplos:
    $ git fetch
    $ git fetch origin <branch>
    $ git fetch <remote> <branch>
    Algo que es común hacer es que luego de hacer un fetch, hacer un git checkout origin/main para desde local en el repositorio remoto sin que los archivos del área de trabajo se vean modificados, esto se puede hacer en VS Code muy intuitivamente.
    
    </div>

switch
    <div>
    para cambiar el HEAD a otra rama, básicamente cambiar de rama de trabajo.
    Específicamente para trabajar con ramas??
    -c
        para crear una nueva rama y cambiar hacia ella. Git muestra un mensaje sobre el cambio del HEAD hacia la nueva rama creada.
        Ejemplo. Crear la nueva rama 'lanzamiento' y cambiar hacia ella:
        $ git switch -c lanzamiento
        Switched to a new branch 'lanzamiento'

    - 
        para cambiar a la rama anterior.
        Ejemplo:
        $ git switch - 
    </div>

diff
    <div>
    compara dos elementos para ver la diferencia. Se puede usar sobre archivos o ramas, también muestra la diferencia entre los cambios que se han realizado desde el último commit.
    Ejemplo. Ver la diferencia entre el último commit y lo avanzado desde ahi:
    $ gid diff
    aquí git muestra información sobre las diferencias...
    Ejemplo. Suponiendo que se está en la rama 'main', compararla con la rama 'login'
    $ git diff login
    </div>

tag
    <div>
    
    </div>

stash
    <div>
    almacena temporalmente los cambios de una rama para poder cambiar a otra rama, trabajar en esta última y luego poder regresar al stash y seguir trabajando sobre ese estado. stash saca del área de trabajo y guarda temporalmente el estado de los archivos sin hacer commits. stash es últil en situaciones en que se está trabajando en una rama digamos 'rama-trabajo' se ha avanzado cambios ahí y se desea cambiar temporalmente a otra rama, a main por ejemplo, para hacer algo rápido o pequeño, terminar eso y regresar a la rama 'rama-trabajo' para seguir trabajando donde se dejo el avance, sin hacer ningún commit en 'rama-trabajo' durante todo este proceso. También es útil cuando se necesita aplicar el mismo avance o cambios a múltiples ramas usando el flag apply.
    Una vez ejecutado este comando todos los archivos agregados al área de preparación serán sacados del área de preparación y puestos en el stash y si se ejecuta status, informará de que no hay cambios en el area de trabajo, como si se hubieran eliminado esos cambios.
    El orden en que se guardan los stash es importante, el último stash creado tendrá el índice 0 y los creados anteriormente serán renumerados consecutivamente, actualizando su índice con cada stash agregado.
    Por defecto, Git no guarda en el stash los cambios hechos en archivos que no se les está haciendo reastreo (archivos untracked) o archivos ignorados (con .ignore) a no ser que se aplique el flag -u.
    Ejemplo. Poner los archivos de stage al stash:
    $ git stash
    esto crea un stash con los archivos. Git muestra un mensaje confirmando la creación del stash

    -m / save
        permite incluir un mensaje con el stash. Esto es muy útil ya que en lugar de que git genere un hash aleatorio para identificar el stash creado, es éste mensaje el identificador, permitiendo un trabajo más fácil cuando se tienen múltiples stash.
        Ejemplo. Crear un stash con el mensaje "hacer mas pruebas"
        $ git stash -m "hacer mas pruebas" # ó
        $ git stash save "hacer mas pruebas"

    list
        para ver lo que se tiene en los stash. Se muestra todos los stash con información almacenada. Si no hay información en stash, este comando no devuelve nada.
        $ git stash list
        stash@{0}: On main: add style to our site
        stash@{1}: WIP on main: de39f5c added README 
        {n}  -> número índice del stash, el último stash creado es el 0
        WIP  -> si no se especifica un mensaje (ver -m), se identifica al stash como work in progress
        on main -> la rama actual sobre la que se está trabajando.
        de39f5c added README -> el hash identificador y mensaje del commit sobre el que se hizo el stash. Si se ha incluido un mensaje para el stash (con -m), este mensaje saldrán en esta posición.

    show
        muestra el contenido del último stash creado (o uno anterior si se especifica un índice con el flag --index).

    pop
        recupera lo que hay almacenado en el último stash creado (o uno anterior si se especifica un índice con el flag --index), para seguir trabajando normalmente y elimina lo que hay en el stash (elimina el stash) de modo que ya no se puede volver a referenciar.

    apply
        recupera lo que hay almacenado en el último stash creado (o uno anterior si se especifica un índice con el flag --index), para seguir trabajando normalmente pero NO elimina lo que hay en el stash (no elimina el stash), pudiendo volver a tener opción de recuperar en otro momento lo que hay en el stash. También es útil cuando se necesita aplicar el mismo avance o cambios a múltiples ramas.
        Sería como una versión más segura de pop ya que no elimina la info.

    drop
        elimina la información del último stash creado (o uno anterior si se especifica un índice con el flag --index) sin opción a recuperarla.

    clear
        elimina toda la pila de stash creados.

    --index
        cuando se trabaja con show, pop, apply, y drop se puede especificar también este flag para que la acción de estos comandos no sea sobre el último stash creado (el índice 0). Ejemplos:
        $ git stash pop --index 1

    -u
        el funcionamiento normal de stash es no agregar archivos que no están siendo rastreados, entonces si se desea incluir archivos no rastreados hay que rastrearlos agregándolos al stage con el comando add. Este flag permite agregar todos los archivos, rastreados y no rastreados al stash, eliminando la necesidad de ejecutar add.

    branch
        Crea una nueva rama y trae información almacenada en un stash hacia esta nueva rama creada y la hace activa para seguir trabajando en ella. Es util cuando al traer información del stash se producen conflictos que hay que solucionar.
        Ejemplo. Traer el stash de index 5 sobre una nueva rama llamada Rev03
        $ git stash branch Rev03 stash@{5} # ó
        $ git stash branch Rev03 5

    </div>

    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
</div>

<h2>PROCESOS</h2>
<div>

    <h3>PARA CREAR UN REPOSITORIO LOCAL (VACÍO)</h3>
    <div>
    
    1.  Abrir la git bash
    2.  Situarse en la carpeta deseada que luego contendrá la carpeta .git que definirá la creación de un repositorio
    3.  Usar el comando init:
        git init
    4.  Listo. la carpeta .git debe haberse creado y se debe mostrar la ruta terminando en '(main)', lo que indica que se está en la rama main del repositorio nuevo.
    
    Tener en cuenta que este proceso NO crea un commit, hay que hacerlo con el comando git commit, lo que será el primer commit del repositorio, a diferencia de crear un repositorio nuevo desde GitHub que automáticamente te crea un commit cuando creas un repositorio nuevo.
    
    </div>
    
    <h3>PARA CREAR UN REPOSITORIO LOCAL Y ENVIARLO LUEGO A REMOTO (GITHUB)</h3>
    <div>
    1.  Tener o crear un repositorio local (con gitbash) que será el que se subirá. Este repositorio es el que tiene los archivos y commits que se desean subir.
    2.  ¿Tener? o crear un nuevo repositorio remoto (en GitHub) que será el que recibirá el repositorio local. No es necesario que éstos dos repositorios tengan el mismo nombre.
    3.  dar visibilidad al repositorio remoto en gitbash. Ejecutar el comando remote con add y la ruta https del repositorio remoto creado en el paso 2:
        git remote add origin https://github.com/usuario/repositorio.git
    4.  Enviar la info del repositorio local al repositorio remoto con push (a la rama main del origin):
        git push origin main
    5.  Gitbash muestra un msg indicando que entre otras cosas, que se ha creado la rama main en el repositorio remoto nuevo creado en el paso 2. Además en VS Code también se empezarán a sincronizar los cambios.
    </div>

    <h3>BIFURCAR (FORK) UN REPOSITORIO</h3>
    <div>
    hay que ir al repositorio que se le quiere hacer el fork y hacer clic en el botón 'fork' listo. El repositorio se bifurcado en tu cuenta de GitHub.
    </div>

    <h3>PARA COMBINAR 2 REPOSITORIOS</h3>
    <div>
    Fuente: https://gist.github.com/msrose/2feacb303035d11d2d05
    </div>

    <h3>PARA ELIMINAR UNO O VARIOS COMMITS PREVIOS</h3>
    <div>
    fuente: https://adictosaltrabajo.com/2023/01/05/como-eliminar-commits-de-la-rama-master/
    Si lo que se desea es eliminar una cantidad X de commits exactamente previos al actual (HEAD), utilizar el comando reset, es simple. Pero si se desea eliminar algún(os) commit(s) que están más atrás en el historial sin tocar los que exactamente preceden al actual se debe seguir los siguientes pasos:
    1.  Se desea eliminar los commits del 2 al 4. Obtener la lista de hash de los commits con git log --oneline. Obtendríamos algo así:
        22dcc79 (HEAD -> main, origin/main, origin/HEAD) commit 5
        d53c00f commit 4
        2c3d41d commit 3
        a323615 commit 2
        ecb7ef3 commit 1
        7ed9c6e creacion de repositorio
        Podemos identificar que los commits a eliminar son d53c00f, 2c3d41d y a323615 (del 2 al 4).
    2.  ejecutamos el comando rebase teniendo en cuenta que se debe retroceder hasta un commit previo a los que se quiere eliminar, en este caso retroceder hasta el comit 1 (ecb7ef3), lo que haría una cantidad de 4 commits a retroceder:
        $ git rebase -i HEAD~4
        Se nos mostrará un archivo nuevo un mensaje con los commits elegidos y una leyenda. Lo que hay que hacer es que delante de los commits a eliminar hay que cambiar la palabra 'pick' por 'drop', también se puede borrar las líneas de esos commits, funciona igual, también se eliminarán esos commits.
    3.  Guardar y cerar este archivo. Listo. Ya se puede hacer push si se desea
        $ git push origin +main
        Prestar especial atención al «+» delante de la rama «main». Este caracter está indicando a git que fuerce el push a dicha rama. Si no se pone git se quejará y no podréis pushear el cambio. Una vez pusheado, comprobar cómo en el historial de commits han desaparecido los commits en cuestión.
    </div>

    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
        
</div>

COMANDOS GENÉRICOS DE LA LÍNEA DE COMANDOS
<div>
cd
    para cambiar directorio. 
    Cuando sólo se escribe cd nos lleva al directorio raíz
cd .. 
    para subir un directorio
cd "ruta"
    para ir a la ruta especificada. Se debe especificar comillas cuando la ruta contiene espacios en blanco

clear
    limpia la pantalla

ls
    para listar archivos y carpetas dentro de la carpeta actual. Las carpetas se diferencian de los archivos por que terminan en /

mkdir
    Make dir. Para crear un directorio

rmdir
    Remove dir. Para eliminar directorios

touch
    para crear archivos en la ruta actual
    Ejemplo. Crear el archivo 'index.html' en la carpeta actual:
    $ touch index.html
    Ejemplo. Crear los archivos 'style.css' y 'script.js':
    $ touch style.css script.js

pwd
    muestra la ruta de trabajo acutal
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------

</div>