<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

<h2>¿Qué es un repositorio?</h2>
<div>
    Es el lugar donde rastreamos cambios, administramos nuestros archivos, y compartimos información.
</div>
    
<h2>AREAS TRABAJO EN GIT</h2>
<div>
    Se refiere al estado en el que puede estar un archivo en git dentro del proceso de "llevar" ese archivo al repositorio. Son 3 áreas:
    
    1. Directorio de trabajo (Working directory): carpeta del proyecto que contiene los archivos, carpetas y el directorio .git del repositorio. Estos componentes NO son parte del repositorio y NO se han añadido al área de preparación. Cuando un archivo se encuentra en esta área decimos que se encuentra en una verisón MODIFICADA (MODIFIED).
    
    -> para pasar a la siguiente área usar el comando add
    
    2. Área de preparación (Stage / Staging area): es el área intermedia en la que se preparan los archivos y cambios que se van a subir al repositorio, es decir, serán incluídos en el próximo commit. Tener en cuenta que ésta no es una área definitiva, aún aquí se pueden agregar o eliminar componentes del futuro commit. Estos componentes NO son parte del repositorio. Cuando un archivo se encuentra en esta área decimos que se encuentra en una versión PREPARADA (ON STAGE).
    
    -> para pasar a la siguiente área usar el comando commit
    
    3. Repositorio (directorio .git): área final (repositorio) donde se encuentran los archivos. Es la parte que se copia cuando clonas un repositorio a tu computadora. El directorio .git contiene los metadatos, ramas y versiones del proyecto que se han ido subiendo. Cuando un archivo se encuentra en esta área decimos que se encuentra en una verisón CONFIRMADA (COMMITTED).
</div>

<h2>¿QUÉ ES UN COMMIT?</h2>
<div>
    Es un componente básico de la línea del tiempo de un proyecto de Git. Es un registro como una foto del estado de un proyecto en un momento especifico. Un commit registra los cambios al detalle en los arhivos en comparación con la versión anterior, si se modificaron, si se agregaron o quitaron, si se cambió el nombre, si se crearon, modificaron o eliminaron carpetas, etc. Todos los cambios entre un commit y otro van a estar registrados en el siguiente commit. La idea es que con los commits podamos rastrear los cambios en los proyectos, cuando se necesite incorporar una nueva versión, agragar funcionalidades, solucionar problemas o incluso regresar a una versión anterior u otras necesidades que marquen un cambio en los archivos del proyecto, se crea un commit.
    
    ## ESTRUCTURA DE UN COMMIT
    Git crea un identificador SHA (Secure Hash Algorithm) único también llamda "hash" para cada commit con el que podremos referirnos a él para ciertas operacines muy útiles. El SHA identifica los cambios realizados, dónde se realizaron los cambios y quién realizó los cambios. Con cada commit, Git también asocia una fecha automática del momento en que se crea el commit.
    Cada vez que se crea un commit se debe especificar un usuario, un correo, una descripción. El usuario y el correo normalmente ya estarán definidos con anterioridad, pero la descripción se tiene que incluir con cada commit. Esta descripción es muy imporante ya que explica de forma concisa el motivo del commit, de manera entendible para otros usuarios o para uno mismo en el futuro.    
    Para crear un commit en git hay que hacerlo con el comnado commit. Ya debe haberse creado un repositorio con el comando init y tener archivos en el área de prepación generados con el comando add.
</div>

<h2>¿Qué es una rama (branch)?</h2>
<div>
    Es una línea independiente de desarrollo en el repositorio, que evolucionará paralelamente a la rama principal y que puede o no volver a unirse a ella, pudiendo tener versiones diferentes del mismo proyecto.
    Para crear una rama o ver las que actualmente existen en el repositorio actual usar el comando branch.
    Para cambiar de rama actual usar el comando checkout.
    Para fusionar ramas usar el comando merge.
</div>

<h2>BIFURCAR UN REPOSITORIO (Fork)</h2>
<div>
    Bifurcar es crear una copia de un repositorio remoto en tu cuenta de GitHub. Es muy útil para cuando queremos trabajar sobre un proyecto (que normalmente no nos pertenece) y no queremos (ni podemos) hacer cambios, pero sí queremos trabajar sobre él para agregarle mejoras, corregir bugs, etc., entonces lo bifurcamos (le hacemos un Fork) en nuestra cuenta, de esa manera se independiza del repositorio original y luego incluso podemos clonarlo a nuestra pc para trabajarlo en local. Este concepto de bifurcar se entrelaza con el de 'pull requests' ya que la idea es trabajar sobre la bifurcación y luego hacer el pull requests para combinar los cambios con el proyecto original.
</div>

<h2>PULL REQUESTS</h2>
<div>
    Un pull requests es una solicitud que uno hace para combinar tus cambios con el repositorio original del proyecto al cual estás contribuyendo. De esta manera es como se implementan por ejemplo nuevas características a los proyectos que son desarrolladas por otros contribuyentes. Uno hace ese cambio en la copia local y luego hace un pull requests para que los desarrolladores del proyecto original la combinen con su proyecto, desde luego, si es aceptada.
    Pull requests sería como la operación inversa de un 'fork', y están muy relacionadas por formar parte de un ciclo que tiene sentido si se trabajan juntas. Ver fork también.
</div>

<h2>Gitignore</h2>
<div>
    es un archivo que deberá encontrarse en la raíz del repositorio y deberá tener el nombre: .gitignore, notar el punto al inicio. Dentro de este archivo se incluirán los archivos, rutas, expresiones que no queremos tener en cuenta para los commits. Basicamente todo lo que no va a formar parte del repositorio.
    faltaaaaaaaa poner como se ponen los datos
</div>


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

COMANDOS GIT
se debe escribir git antes de cada comando

config
    para la configuración de git.

    --global
        para que las configuraciones que se hagan afecten a todo git. Se se omite, las configuraciones afectarán sólo al repositorio actual.

    user.name "nombre"
        para configurar el nombre del ususario de git. Normalmebte debría ser el nombre del ususario de la cuenta de github ya que este nombre es el que aparecerá en los commits que este usuario suba. Si no se especifica el argumento nombre, devuelve el nombre actual. configurado.

    user.email "correo"
        para configurar el correo del usuario de git. Normalmente debería ser el correo del usuario de la cuenta de github ya que este correo es el que aparecerá en los commits que este usuario suba. Si no se especifica el argumento correo, devuelve el correo actual.
    
    core.editor
        para asociar un editor (IDE) con Git.
        Ejemplo. Asociar Visual Studio Code con Git:
        $ git config --global core.editor "code --wait"
        --wait le dice a Git que espere hasta que el archivo se guarde, y se cierre para culminar con el commit

    alias 
        para poner nombres a secuencias de comandos, algo similar a una macro. Luego para ejecutar esa macro solo hay que introducir el nombre del nuevo alias.
        Ejemplo 1: crear un alias de nombre 'macro'
        $ git config --global alias.macro "log --graph --decorate --all --oneline"
        $ git macro
        Ejemplo 2: crear un alias de nombre 'l1' que sirve para mostrar todos los logs en una sola línea:
        $ git config --global alias.l1 "log --all --oneline"
        $ git l1

        Este alias se guarda en el archivo .gitconfig dentro de la carpta de usuario del sistema.

init
    (Initialize) Inicializa un repositorio git vacío ¿local? en la carpeta actual. Crea la carpeta .git en la que se encuentra toda la info del repositorio. Si se borra esta carpeta el respositorio no existirá.

    .defaultBranch "nombre"
        cambia la denominación (no el nombre) de un repositorio o de todos los repositorios futuros, se decir, el nombre por defecto.
        Ejemplo. para cambiar la denominación por defecto de los respositorios futuros a "main":
        $ git config --global init.defaultBranch main

status
    Para verificar el estado del repositorio. Muestra la rama actual, los commits realizados, los componentes en el área de preparación etc. Tener en cuenta que este comando sólo nos muestra info de los repositorios locales. Si se actualiza un repositorio remoto, status no nos podrá decir si nuestros repositorio local está actualizado. Si se desea verificar el estado de nuestro repositorio local respecto al remoto utilizar el comando fetch y si se desea descargar y combinar lo que hay remoto con lo que hay en local utilizar el comando pull

add
    para agregar archivos desde el directorio de trabajo hacia el área de preparación. 
    Ejemplo. Para agregar el archivo mi-archivo.txt al área de preparación:
    $ git add mi-archivo.txt
    Se puede obviar escribir el nombre de los archivos escribiendo un punto en lugar de los archivos. 
    Ejemplo. Agregar los arhchivos modificados cualesquiera q sean al stage:
    $ git add .

rm
    --cached
            para eliminar archivos del área de preparación. Estos archivos regresarán a ser parte del directorio de trabajo. 
            Ejemplo. para remover el archivo mi-archivo.txt del área de preparación:
            $ git rm --cached mi-archivo.txt

commit
    Sube los cambios del área de preparación al repositorio. Ya debe haberse creado un repositorio con el comando init y tener archivos en el área de prepación generados con el comando add. Se puede incluir una descripción con el flag -m.
    Ejemplo. Crea un commit con la descripción de que se está agregando el archivo mi-archivo.txt:
    $ git commit -m "Agregar archivo: mi-archivo.txt"
    Lo ideal es trabajar en conjunto con visual studio code para trabajar la descripción de manera más interactiva y no con el flag -m. Para hacer esto sólo hay que ejecutar este comando sin argumentos ni flags: git commit y enter, esto hará que se abra VS Code con un archivo y esperará a que se guarde y se cierre para terminar con el commit. Para crear commits dentro de una rama sólo hay que estar en ella.
    
    --amend
        para modificar un commit. Hay que tener mucho cuidado con editar commits ya que ya podría haber sido descargado por otro usuario antes de hacer la modificación. Lo recomendable es hacer estas modificaciones en local. --amend espera a que se cierre el archivo de mensaje (en le editor) para terminar con la edición del commit.

    -m 
        para indicar el mensaje del commit. Tiene que ser sí o sí una única línea.

log
    Muestra el historial de commits realizados con su respectiva información descriptiva (SHA, rama, autor, correo, fecha, descripción)

    --oneline
        para mostrar el historial de commits cada uno en una linea.

    -p
        para ver las diferencias entre los commits. no entiendo bien los mensajes en este modo !!!!!!!!!!

    --graph
        muestra el log de commits con 'lineas' simulando la secuencia gráfica de los commits.
    
reflog
    
reset
    para dehacer un commit (eliminarlo). 
    Ejemplo. Para eliminar el último commit:
    $ git reset --soft HEAD~1
    --soft : los archivos en el directorio de trabajo nose ven afectado por la eliminación del commit, quedan tal cual están antes de eliminar el commit, quedarían en el working area. En Visual Studio quedarían marcados con la letra M en señal de que están modificados, ya que esa es su situación real
    ahora, el commit que los actualizó en el repositorio ya no existe por tanto son cambios pendientes de agregar al stage y luego al repositorio como si fueran archivos que nunca se subieron.
    HEAD~1 : deshace un cambio desde el HEAD (desde lo último commit subido)

branch
    Para crear ramas nuevas en el repositorio o ver las que actualmente existen, borrar ramas.
    Ejemplo. Crear una rama con el nombre version-JavaScript:
    $ git branch version-JavaScript
    Ejemplo. Para ver (listar) las rammas que actualmente existe:
    $ git branch
    La rama en la que se está trabajando (actual) tiene un * al inicio
    
    -m
        para cambiar el nombre de una rama. hay 2 formas de cambiar el nombre a una rama:
        1° Indicando sólo el nuevo nombre. De esta forma necesario que la rama a la que se desea cambiar nombre sea la rama actual.
        Ejemplo. Cambiar de nombre a la rama actual a "version-js":
        $ git branch -m version-js
        2° Indicando el nombre antiguo y el nuevo nombre de la rama a cambiar. De esta forma no es necesario estar en la rama a la que renombrar.
        Ejemplo. Cambiar el nombre de la rama "version-JavaScript" a "version-js":
        $ git branch -m version-JavaScript version-js

    -d
        Para borrar una rama. Esto aplica para repositorios locales, no en las ramas que ya están publicadas en Github. Si la eliminación fue exitosa, Git muestra un mensaje confirmando la eliminación de la rama. La rama main (o principal) no se puede eliminar, tampoco se puede borrar la rama actual, se debe borrar desde otra rama.
        Ejemplo. Borrar la rama "version-py":
        $ git branch -d version-py
    
    -a 
        visualiza todas las ramas disponibles en el repositorio incluidas las ramas remotas las cuales empiezan con 'remotes/origin' para denotar su estado remoto e indicar su presencia en un serivdor remoto:
        $ git branch -a
        * main
        remotes/origin/HEAD -> origin/main
        remotes/origin/feature-x
        remotes/origin/feature-y
        remotes/origin/release-1.0
        Este comando es muy importante dado que si se desea ser parte de un proyecto, el chequeo de las ramas siempre debe ser el primer paso.

checkout
    para cambiar de rama actual (puede ser una versión remota incluso), o regresar a una  versión de commit anterior, o para crear una nueva rama y cambiar a esa rama como actual, o para revertir los cambios de un archivo 
    Cuando se ejecuta este comando, Git muestra el mensaje: Switched to branch ... indicando el cambio a la rama indicada.
    Ejemplo. Cambiar a la rama version-JavaScript:
    $ git checkout version-JavaScript
    
    -b 
        crea una rama nueva rama nueva.
        Ejemplo. Crear y cambiar a una rama llamada version-Python
        $ git checkout -b version-Python
    
    origin/main
        Cambia al repositorio REMOTO origin y a su rama main pero para trabajar de manera local. En este caso se muestra un msg que se puede hacer cambios en local que no van a modificar la información en el remoto. Es muy útil ya que si se trabaja con VS Code, se puede los cambios realizados en el repositorio retomo pero en la máquina local.
        Para que funcione adecuadamente, es necesario antes haber hecho un 'fetch' ya que sino la máquina local no sabrá qué cambios existen en el repositorio remoto, y si luego se necesita regresar a una rama local, main por ejemplo, se ejecuta el comando git switch main.

    <nombre de archivo>
        se puede usar checkout con el nombre de un archivo para deshacer los cambios que se ha hecho en ese archivo. Esto revertirá la archivo a la versión HEAD.
        Ejemplo. Eliminar (revertir) los cambios realizados desde el último commit en el archivo index.html
        $ git checkout index.html

    <hash>
        regresa a un commit anterior, para ello hay q indicar el hash del commit al que se desea regresar o parte del hash.
        Ejemplo. Ir al commit con el hash cd5f8b9:
        $ git checkout cd5f8b9
        En este momento, git informa de la situación en la que ha entrado: estarás desconectado del estado de HEAD, por lo tanto, podrás hacer los cambios que quieras sin que haya problema con las ramas anteriormente establecidas en el git checkout. Ahora, si en este momento quieres deshacer los cambios que has realizado, podrás utilizar la instrucción git switch – y, si quieres guardar los cambios que hayas hecho, puedes introducir la instrucción git switch -c <new-branch-name>. 
        Notar que con este comando, si hay cambios que NO se han agregado a un repositorio, estos cambios pueden perderse (pueden ser sobreesctitos por el checkout). Git informa de esta situación en vez de ejecutar el comando. El mensaje que muestra es como este:
        $ git checkout cd5f8b9 
        error: Your local changes to the following files would be overwritten by checkout:
            index.html
        Please commit your changes or stash them before you switch branches.
        Aborting
        Será necesario entonces realizar un commit para que todos nuestros cambios estén seguros
merge
    para fusionar ramas. Se debe estar en la rama que recibirá la fusión. Notar que mientras se está haciendo la fusión, el mensaje de Git sobre la rama actual muestra también la palabra MERGING: (main|MERGING)
    Ejemplo. Fusionar la rama "version-js" con la rama actual:
    $ git merge version-js

    --continue
        Cuando una fusión de ramas tiene conflictos, primero hay que solucionar esos conflictos y luego continuar el proceso de fusión con este comando. Cuamdo se ejecuta este comando los conflictos deben estar solucionados ya que serán subidos al repositorio como un nuevo commit, en VS Code se abre una pestaña nueva esperando confirmar el mensaje de descripción y cerrar el archivo para terminar con la fusión y el commit automático. Al terminar la fusión Git muestra un msg indicando lo correspondiente.
        En el siguiente texto se ha unido la rama 'version-js' a la rama main:
        HP@HPV MINGW64 ~/ruta-reposistorio (main|MERGING)
        $ git merge --continue
        [main 34fd113] Merge branch 'version-js'

clone   
    Crea una copia local de un repositorio remoto. Este repositorio remoto está alojado en GitHub y ahí hay que obtener la dirección HTTPS de clonación del repositorio para agregarla como argumento a este comando. Hay que tener en cuenta que git crea el repositorio en la carpeta que actualmente se está trabajando, por tanto ante de ejecutar este comando hay que asegurarse estar en la carpeta adecuada. Git mostrará unos mensajes del proceso indicando que el proceso ha sido realizado al 100%
    Ejemplo. Clonar el repositorio de GitHub 'nuevo-proyecto':
    $ git clone https://github.com/usuario/nuevo-proyecto.git
    En este caso la dirección htts ha sido obtenida del repositorio en la web de GitHub.
    Pero ocurre algo al querer enviar los cambios de vuelta al repositorio remoto, en este caso solo hemos hecho una copia en local. Si intentamos hacer git push tendremos un error ya que no hemos definido ningún origen remoto para este directorio. Para guardar en forma remota (usando GitHub) debemos crear un repositorio, conectarlo a nuestra carpeta local con 'git remote add origin ruta' y de esa forma estaremos habilitados para guardar los cambios en remoto.
    Notar que 'clone' sólo hace un clon de la rama principal del repositorio remoto y el resto de ramas no se clonan al local. 
    Para clonar un repositorio con todas sus ramas: 
        https://www.baeldung.com/ops/git-clone-remote-branches
        https://www.geeksforgeeks.org/how-to-clone-all-remote-branches-in-git/
    Para ver las ramas remotas (que existen en el repositorio remoto en GitHub) ejecutar 'git branch -a'.

remote
    Para ver los repositorios remotos que actualmente tienen conexión con la pc local o para establecer esa conexión con los repositorios remotos, estas conexiones se realiza a través de la URL del repositorio, y para no estar tecleando siempre esa URL se puede poner un nombre a esa conexión, normalmente la primera conxión en una sesión de trabajo se le suele llamar por convención 'origin', las siguientes conexiones con otros repositorios en la misma sesión de trabajo deberán tener otros nombres. También sirve para renombrar y eliminar conexiones con repositorios remotos.
    Si se ha clonado un repositorio se debería ver al menos 'origin' que es el nombre que le da Git por defecto al servidor del que has clonado.
    Verifica el nombre que se le ha asignado al repositorio remoto en GitHub para trabajar con Git. Éste NO es el nombre del repositorio real cuando se creó y no lo sustiruirá, es sólo un nombre temporal para trabajar con el repositorio local y remotamente a la vez.
    Una vez que se establece una conexión con un repositorio remoto, se puede utilizar por ejemplo el comando 'push' para subir nuestros cambios al repositorio remoto o 'pull' para bajar cambios a nuestra pc.

    -v
        muestra las direcciones del repositorio origen para push (enviar cambios) y fetch (visualizar cambios). Nommalmente serán la misma dirección para ambos. Este comando no muestra ninguna info si no hay respositorios conectados. Utilizar add para agregar repositorios remotos antes de utilizar este comando.
    
    add
        Añade una conexión de un repositorio remoto al repositorio local para poder actualizar cambios u otras cosas. Este comando no crea commits ni sube archivos ni hace nada de ello, Lo único que hace es crear la conexión, para ello hay que indicar la dirección o link del repositorio remoto. La idea es añadir un repositorio y asociarlo a un nombre que luego se pueda referenciar fácilmente, normalmente este nombre es 'origin' para cuando se trabaja con un solo repositorio, pero si se desea agregar más, se debe utilizar otros nombres, luego puedes usar ese nombre en línea de comandos en lugar de la dirección URL entera.
        Después de este comando se puede utilizar -v para ver las direcciones de estos remotos.
        Ejemplo. Agregar un repositorio remoto de nombre 'origin':
        $ git remote add origin https://github.com/usuario/.....git
        Ejemplo. Agregar un repositorio remoto de nombre 'opcion2':
        $ git remote add opcion2 https://github.com/usuario/.....git

    rename <oldname> <newname>
        para renombrar un repositorio remoto

    remove <name>
        para eliminar la conexion con un repositorio remoto.

push
    Envía los cambios realizados en un repositorio local a un repositorio remoto para que ambos tengan la misma información y estén sincronizados. Es necesario que exista una conexión entre el repositorio local y el remoto la cual se puede configurar o verificar con el comando 'remote'
    ¿push hace un commit???
    Ejemplo. Enviar datos desde un repositorio local a la rama main de un repositorio remoto:
    $ git push origin main
    Ejemplo. Enviar datos desde un repositorio local a la rama nueva-rama de un repositorio remoto:
    $ git push origin nueva-rama
    En este caso si la rama en remoto no existe, se crea automáticamente.

    -u


pull
    Descarga el contenido de un repositorio remoto e inmediatamente actualiza un repositorio local para que ambos tengan la misma información si no hay conflictos. A diferencia del comando fetch, pull combina los cambios automáticamente.
    Si no hay cambios en el remoto, este comando no hace nada. No es necesario luego usar otro comando como fetch. Lo que si puede ser necesario es utiliar el comando log para ver los nuevos commits traídos a local
    Ejemplo. Para actualizar un repositorio local desde uno remoto origni (verificar este nombre con git remote -v) hacia nuestra rama main:
    $ git pull origin main

fetch
    Verifica si se han realizado cambios en el repositorio remoto desde la última vez que actualizaste tu respositorio local con git pull, sin combinar esos cambios con el repositorio local y nos permite ver como una vista previa de esos cambios y luego podemos elegir si queremos conbinarlos o no con el comando merge. Se diferencia del comando pull que sí combina los cambios.
    Ejemplo
    $ git fetch origin
    Algo que es común hacer es que luego de hacer un fetch, hacer un git checkout origin/main
    

switch
    para cambiar de rama
    faltaaaaaaaaaaaaaaaaaaaaaaaaaa

diff
    compara dos elementos para ver la diferencia. Se puede usar sobre archivos o ramas...
    Ejemplo. Suponiendo que se está en la rama 'main', compararla con la rama 'login'
    $ git diff login

tag


stash
    almacena temporalmente los cambios de una rama para poder cambiar a otra sin hacer commits. 

    list
        para ver lo que se tiene en los stash. Se muestra todos los stash con información almacenada. Si no hay información en stash, este comando no devuelve nada.

    pop
        recupera lo que hay almacenado en el stash para seguir trabajando normalmente.

    drop
        elimina la información del stash sin recuperarla.

reflog
    para ver el registro de todo

    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------


    # PROCESOS

    ## PARA CREAR UN REPOSITORIO LOCAL (VACÍO)
    
    1.  Abrir la git bash
    2.  Situarse en la carpeta deseada que luego contendrá la carpeta .git que definirá la creación de un repositorio
    3.  Usar el comando init:
        git init
    4.  Listo. la carpeta .git debe haberse creado y se debe mostrar la ruta terminando en '(main)', lo que indica que se está en la rama main del repositorio nuevo.
    
    Tener en cuenta que este proceso NO crea un commit, hay que hacerlo con el comando git commit, lo que será el primer commit del repositorio, a diferencia de crear un repositorio nuevo desde GitHub que automáticamente te crea un commit cuando creas un repositorio nuevo.
    
    
    ## PARA CREAR UN REPOSITORIO LOCAL Y ENVIARLO LUEGO A REMOTO (GITHUB)
    ENVIAR!!
    
    1.  Tener o crear un repositorio local (con gitbash) que será el que se subirá. Este repositorio es el que tiene los archivos y commits que se desean subir.
    2.  ¿Tener? o crear un nuevo repositorio remoto (en GitHub) que será el que recibirá el repositorio local. No es necesario que éstos dos repositorios tengan el mismo nombre.
    3.  dar visibilidad al repositorio remoto en gitbash. Ejecutar el comando remote con add y la ruta https del repositorio remoto creado en el paso 2:
        git remote add origin https://github.com/usuario/repositorio.git
    4.  Enviar la info del repositorio local al repositorio remoto con push (a la rama main del origin):
        git push origin main
    5.  Gitbash muestra un msg indicando que entre otras cosas, que se ha creado la rama main en el repositorio remoto nuevo creado en el paso 2. Además en VS Code también se empezarán a sincronizar los cambios.
    
    ## BIFURCAR (FORK) UN REPOSITORIO
    hay que ir al repositorio que se le quiere hacer el fork y hacer clic en el botón 'fork' listo. El repositorio se bifurcado en tu cuenta de GitHub.
    
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
        
COMANDOS GENÉRICOS DE LA LÍNEA DE COMANDOS

cd
    para cambiar directorio. 
    Cuando sólo se escribe cd nos lleva al directorio raíz
cd .. 
    para subir un directorio
cd "ruta"
    para ir a la ruta especificada. Se debe especificar comillas cuando la ruta contiene espacios en blanco

clear
    limpia la pantalla

ls
    para listar archivos y carpetas dentro de la carpeta actual. Las carpetas se diferencian de los archivos por que terminan en /

mkdir
    Make dir. Para crear un directorio

rmdir
    Remove dir. Para eliminar directorios
    

    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------

<h2>Visual Studio Code</h2>
<h3>Para ver los archivos ocultos en VS Code (carpetas .git por ejemplo).</h3>
<div>
    1. Ir a file > Preferences > Settings (o Ctrl + ,)
    2. En la columna de la izquierda seleccionar: User > Commonly used > Text editor > Files
    3. En el panel de la derecha buscar el item 'Exclude'
    4. Posar el cursor sobre la opción que dice **/.git y hacia la derecha hacel clic en la X para eliminar este item. Se le está diciendo a VS Code que NO se quiere ocultar las carpetas '.git'
    Con esto la carpeta .git debería aparecer en la lista de archivos/carpetas de VS Code disponibles para trabajar.
</div>


</body>
</html>
