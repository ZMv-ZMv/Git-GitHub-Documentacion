<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

<h2>¿Qué es Git</h2>
<div>
    Es un sistema de control de versiones que nos permite rastrear o administrar los cmabios que hemos hecho en un conjunto de archivos.
</div>

<h2>¿Qué es un repositorio?</h2>
<div>
    Es el lugar donde se almacenan archivos con sus distintas versiones, rastreamos y administramos sus cambios, y compartimos esa información con otros usuarios.
    Un repositorio de acuerdo a su ubicación puede ser de dos formas:
    1. Local. Se ubicará en nuestra pc (normalmente en la pc en el que se creó) y sólo nosotros podremos acceder a él.
    2. Remoto. Se ubicará en la nube, en algún servidor como en GitHub por ejemplo, esto siginifica que podrá ser accesible por varios usuarios al mismo tiempo.
    Un repositorio local puede ser enviado a un repositorio remoto y viceversa en cualquier momento. Esta sería la mejor forma de trabajar ya que permitirá que la información esté actualizada en todo momento en todos sitios.
</div>
    
<h2>AREAS TRABAJO EN GIT</h2>
<div>
    Se refiere al estado en el que puede estar un archivo en git dentro del proceso de "llevar" ese archivo al repositorio. Son 3 áreas:
    
    1. Directorio de trabajo (Working directory): carpeta del proyecto que contiene los archivos, carpetas y el directorio .git. Estos componentes NO son parte del repositorio y NO se han añadido al área de preparación. Cuando un archivo se encuentra en esta área decimos que se encuentra en una verisón MODIFICADA (MODIFIED).
    
    -> para pasar a la siguiente área usar el comando add
    
    2. Área de preparación (Stage / Staging area): es el área intermedia en la que se preparan los archivos y cambios que se van a subir al repositorio, es decir, serán incluídos en el próximo commit. Tener en cuenta que ésta no es una área definitiva, aún aquí se pueden agregar o eliminar componentes del futuro commit. Estos componentes NO son parte del repositorio. Cuando un archivo se encuentra en esta área decimos que se encuentra en una versión PREPARADA (ON STAGE).
    
    -> para pasar a la siguiente área usar el comando commit
    
    3. Repositorio (directorio .git): área final (repositorio) donde se encuentran los archivos. Es la parte que se copia cuando clonas un repositorio a tu computadora. El directorio .git contiene los metadatos, ramas y versiones del proyecto que se han ido subiendo. Cuando un archivo se encuentra en esta área decimos que se encuentra en una verisón CONFIRMADA (COMMITTED).
</div>

<h2>¿QUÉ ES UN COMMIT?</h2>
<div>
    Es un componente básico de la línea del tiempo de un proyecto de Git. Es un registro como una foto del estado de un proyecto en un momento especifico. Un commit registra los cambios al detalle en los arhivos en comparación con la versión anterior, si se modificaron, si se agregaron o quitaron, si se cambió el nombre, si se crearon, modificaron o eliminaron carpetas, etc. Todos los cambios entre un commit y otro van a estar registrados en el siguiente commit. La idea es que con los commits podamos rastrear los cambios en los proyectos, cuando se necesite incorporar una nueva versión, agragar funcionalidades, solucionar problemas o incluso regresar a una versión anterior u otras necesidades que marquen un cambio en los archivos del proyecto, se crea un commit.
    
    ## ESTRUCTURA DE UN COMMIT
    Git crea un identificador SHA (Secure Hash Algorithm) único también llamda "hash" para cada commit con el que podremos referirnos a él para ciertas operacines muy útiles. El SHA identifica los cambios realizados, dónde se realizaron los cambios y quién realizó los cambios. Con cada commit, Git también asocia una fecha automática del momento en que se crea el commit.
    Cada vez que se crea un commit se debe especificar un usuario, un correo, una descripción. El usuario y el correo normalmente ya estarán definidos con anterioridad, pero la descripción se tiene que incluir con cada commit. Esta descripción es muy imporante ya que explica de forma concisa el motivo del commit, de manera entendible para otros usuarios o para uno mismo en el futuro.    
    Para crear un commit en git hay que hacerlo con el comnado commit. Ya debe haberse creado un repositorio con el comando init y tener archivos en el área de prepación generados con el comando add.
</div>

<h2>¿Qué es una rama (branch)?</h2>
<div>
    Es una línea independiente de desarrollo en el repositorio, que evolucionará paralelamente a la rama principal y que puede o no volver a unirse a ella, pudiendo tener versiones diferentes del mismo proyecto.
    Internamente en Git, cuando se crea una rama sólo se está creado un puntero a un commit, no se cambia ningún otro aspecto en el repositorio.
    Para crear una rama o ver las que actualmente existen en el repositorio actual usar el comando branch.
    Las ramas pueden también renombrarse, incluso la rama principal puede ser renombrada en cualquier momento.
    Para cambiar de rama actual usar el comando checkout.
    Para fusionar ramas usar el comando merge.
</div>

<h2>¿Qué es el HEAD?</h2>
<div>
    El término HEAD es una referencia a un commit, un puntero que apunta a un commit específico de una rama la cual actualmente se está viendo o trabajando, es decir, nos da referencia de en qué rama estamos trabajando actualmente.
    Normalmente el HEAD apunta al último commit de la rama actual (en el que estamos trabajando), pero en cualquier momento podemos regresar a trabajar sobre un commit anterior levando el HEAD hacia ese commit, desde ese momento cualquier commit que creemos sobre el commit al que hemos regresado, deberá crearse sobre una rama nueva, ya que se supone que existe una rama que se ha estado desarrollando y está más avanzada (la rama desde la cual regresamo a un commit anterior) y esa rama no puede modificarse desde una rama anterior sin crear una nueva.
    Para moverse entre ramas o commits para desplazar el HEAD, usar el comando checkout.

</div>

<h2>¿Qué es el Detached HEAD?</h2>
<div>
    Normalmente el HEAD lo tenemos ubicado sobre (apunta a) el último commit de una rama, pero habrá veces en las que se desea regresar a commits anteriores para ver el historial del desarrollo, en este caso el HEAD no apuntará al último commit de la rama, sino que estará ubicado en cualquier commit antecesor al que lo hayamos desplazado, a esta situación se le denomina 'Detached HEAD'. Detached por que aunque estamos actualmente sobre un commit, éste al no ser último de la rama, no puede sufrir cambios, a menos que en ese momento creemos una rama nueva para guardar esos cambios. En caso de que hagamos cambios y no creemos esa nueva rama, los cambios no serán permanentes y se eliminarán tan pronto cambiemos el HEAD de posición.
    Para cambiar de posición el HEAD a un commit anterior o a otra rama, utilizar el comando checkout.
    El hecho de mover el HEAD hacia un commit antecesor (hacerle Detached HEAD), NO significa que se va a deshacer lo avanzado, no se modificará nada, es sólo que se está cambiando de posición el HEAD, simplemente se está explorando un commit antecesor.
</div>

<h2>BIFURCAR UN REPOSITORIO (Fork)</h2>
<div>
    Bifurcar es crear una copia de un repositorio remoto en tu cuenta de GitHub. Es muy útil para cuando queremos trabajar sobre un proyecto (que normalmente no nos pertenece) y no queremos (ni podemos) hacer cambios, pero sí queremos trabajar sobre él para agregarle mejoras, corregir bugs, etc., entonces lo bifurcamos (le hacemos un Fork) en nuestra cuenta, de esa manera se independiza del repositorio original y luego incluso podemos clonarlo a nuestra pc para trabajarlo en local. Este concepto de bifurcar se entrelaza con el de 'pull requests' ya que la idea es trabajar sobre la bifurcación y luego hacer el pull requests para combinar los cambios con el proyecto original.
</div>

<h2>PULL REQUESTS</h2>
<div>
    Un pull requests es una solicitud que uno hace para combinar tus cambios con el repositorio original del proyecto al cual estás contribuyendo. De esta manera es como se implementan por ejemplo nuevas características a los proyectos que son desarrolladas por otros contribuyentes. Uno hace ese cambio en la copia local y luego hace un pull requests para que los desarrolladores del proyecto original la combinen con su proyecto, desde luego, si es aceptada.
    Pull requests sería como la operación inversa de un 'fork', y están muy relacionadas por formar parte de un ciclo que tiene sentido si se trabajan juntas. Ver fork también.
</div>

<h2>Gitignore</h2>
<div>
    es un archivo que deberá encontrarse en la raíz del repositorio y deberá tener el nombre: .gitignore, notar el punto al inicio. Dentro de este archivo se incluirán los archivos, rutas, expresiones que no queremos tener en cuenta para los commits. Basicamente todo lo que no va a formar parte del repositorio.
    faltaaaaaaaa poner como se ponen los datos
</div>


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

COMANDOS GIT
<div>
se debe escribir git antes de cada comando

config
    <div>
    para la configuración de git.
    --global
        para que las configuraciones que se hagan afecten a todo git. Se se omite, las configuraciones afectarán sólo al repositorio actual.
    init.defaultBranch
        para definir el nombre por defecto de la rama principal cuando se crea un repositorio.
        Ejemplo. Definir el nombre 'main':
        $ git config --global init.defaultBranch main
    user.name "nombre"
        para configurar el nombre del ususario de git. Normalmebte debría ser el nombre del ususario de la cuenta de github ya que este nombre es el que aparecerá en los commits que este usuario suba. Si no se especifica el argumento nombre, devuelve el nombre actual. configurado.
    user.email "correo"
        para configurar el correo del usuario de git. Normalmente debería ser el correo del usuario de la cuenta de github ya que este correo es el que aparecerá en los commits que este usuario suba. Si no se especifica el argumento correo, devuelve el correo actual.
    
    core.editor
        para asociar un editor (IDE) con Git.
        Ejemplo. Asociar Visual Studio Code con Git:
        $ git config --global core.editor "code --wait"
        --wait le dice a Git que espere hasta que el archivo se guarde, y se cierre para culminar con el commit
    alias
        para poner nombres a secuencias de comandos, algo similar a una macro. Luego para ejecutar esa macro solo hay que introducir el nombre del nuevo alias.
        Este alias se guarda en el archivo .gitconfig dentro de la carpta de usuario del sistema.
        Ejemplo 1: crear un alias de nombre 'macro'
        $ git config --global alias.macro "log --graph --decorate --all --oneline"
        $ git macro
        Ejemplo 2: crear un alias de nombre 'l1' que sirve para mostrar todos los logs en una sola línea:
        $ git config --global alias.l1 "log --all --oneline"
        $ git l1
        Ejemplo. Crear un alias para status --short:
        $ git config --global alias.ss "status --short"
        Ejemplo. Crear un alias para checkout main
        $ git config --global alias.cm "checkout main"
    </div>

init
    <div>
    (Initialize) Inicializa un repositorio git vacío ¿local? en la carpeta actual. Crea la carpeta .git en la que se encuentra toda la info del repositorio. Si se borra esta carpeta el respositorio no existirá.
    .defaultBranch "nombre"
        cambia la denominación (no el nombre) de un repositorio o de todos los repositorios futuros, se decir, el nombre por defecto.
        Ejemplo. para cambiar la denominación por defecto de los respositorios futuros a "main":
        $ git config --global init.defaultBranch main
    </div>

status
    <div>
    Para verificar el estado del repositorio. Muestra la rama actual, los componentes en el área de preparación, los componentes no rastreados, etc. Tener en cuenta que este comando sólo nos muestra info de los repositorios locales. Si se actualiza un repositorio remoto, status no nos podrá decir si nuestros repositorio local está actualizado. Si se desea verificar el estado de nuestro repositorio local respecto al remoto utilizar el comando fetch y si se desea descargar y combinar lo que hay remoto con lo que hay en local utilizar el comando pull

    --short
        para ver el estado de archivos con la info de manera acortada. El estado de los archivos se muestra con el siguiente texto incial:    
        ?? - para archivos no que están rastreando
        A - para archivos agregados al stage
        M - para archivos modificados
        D - para archivos eliminados
    
    </div>

add
    <div>
    para agregar archivos desde el directorio de trabajo hacia el área de preparación, es decir, los pasará de una versión MODIFICADA a una versión PREPARADA.
    Ejemplo. Para agregar el archivo mi-archivo.txt al área de preparación:
    $ git add mi-archivo.txt
    Se puede obviar escribir el nombre de los archivos escribiendo un punto en lugar de los archivos.
    Ejemplo. Agregar los arhchivos modificados cualesquiera q sean al stage:
    $ git add .
    </div>

rm
    <div>
    --cached
            para regresar archivos del área de preparación al área de trabajo. Estos archivos regresarán a ser parte del directorio de trabajo, es decir, el archivo volverá en una versión MODIFICADA, y el comando status lo mostrará como 'untracked'.
            Ejemplo. para remover el archivo mi-archivo.txt del área de preparación:
            $ git rm --cached mi-archivo.txt
            rm 'mi-archivo.txt'
    </div>

commit
    <div>
    Sube los cambios del área de preparación al repositorio. Ya debe haberse creado un repositorio con el comando init y tener archivos en el área de prepación generados con el comando add. Se puede incluir una descripción con el flag -m.
    Ejemplo. Crea un commit con la descripción de que se está agregando el archivo mi-archivo.txt:
    $ git commit -m "Agregar archivo: mi-archivo.txt"
    Lo ideal es trabajar en conjunto con visual studio code para trabajar la descripción de manera más interactiva y no con el flag -m. Para hacer esto sólo hay que ejecutar este comando sin argumentos ni flags: git commit y enter, esto hará que se abra VS Code con un archivo y esperará a que se guarde y se cierre para terminar con el commit. Para crear commits dentro de una rama sólo hay que estar en ella.
    
    --amend
        para modificar un commit. Hay que tener mucho cuidado con editar commits ya que ya podría haber sido descargado por otro usuario antes de hacer la modificación. Lo recomendable es hacer estas modificaciones en local. --amend espera a que se cierre el archivo de mensaje (en le editor) para terminar con la edición del commit.
    -m
        para indicar el mensaje del commit. Tiene que ser sí o sí una única línea, pero se puede usar múltiples -m por cada línea que se desea agregar al mensaje.

    -a
        evita usar el comando add, lo que hace que se pueda realizar un commit sin estar mandando archivos al stage explicitamente ya que este flag lo hace automáticamente. No debería utilizarse este flag en commits complejos ya que podria incluir resultados inesperados.

    --allow-empty
        permite realizar commits sin cambios en los archivos. Sería como hacer un commit vacío.
        El funcionamiento normal de git no permite que se hagan commits sin cambios en los archivos, es decir, si se trata de realizar un commit 'vacío' git mostrará un mensaje alertando de esta situación y no realiza el commit, con este flag se puede saltar esta advertencia y realizar el commit.
        Ejemplo. Realizar un commit vacío con mensaje 'empty commit'
        $ git commit --allow-empty -m "empty commit"

    --allow-empty-message
        permite crear commits sin mensaje.
    </div>

log
    <div>
    Muestra el historial de commits realizados con su respectiva información descriptiva (SHA, rama, autor, correo, fecha, descripción)
    --oneline
        para mostrar el historial de commits cada uno en una linea.
    -p
        para ver las diferencias entre los commits. no entiendo bien los mensajes en este modo !!!!!!!!!!
    --graph
        muestra el log de commits con 'lineas' simulando la secuencia gráfica de los commits.
    
    </div>

reflog
    <div>
    para ver el registro de todo
    </div>

reset
    <div>
    para dehacer un commit (eliminarlo).
    Ejemplo. Para eliminar el último commit:
    $ git reset --soft HEAD~1
    --soft : los archivos en el directorio de trabajo nose ven afectado por la eliminación del commit, quedan tal cual están antes de eliminar el commit, quedarían en el working area, es decir, es el commit lo que desaparece, los archivos y sus cambios permanecen intactos. En Visual Studio quedarían marcados con la letra M en señal de que están modificados, ya que esa es su situación real
    ahora, el commit que los actualizó en el repositorio ya no existe por tanto son cambios pendientes de agregar al stage y luego al repositorio como si fueran archivos que nunca se subieron. Este flag no es necesario indicarlo ya que es el comportamiento por defecto. Una sitaución donde se utilizaría este comando con --soft es cuando se ha realizado un commit en una rama equivocada, en este caso se necesita mantener lo avanzado en los archivos, pero no el commit, por lo que el reset tendría sentido.
    Si se desea eliminar también los archivos tanto como los commits se debe reemplazar este flag por el flag --hard. Tener en cuenta que esta acción es irrevocable.
    HEAD~1 : deshace un cambio desde el HEAD (desde lo último commit subido)
    Tener en cuenta que este comando puede crear commits huérfanos ya que si por ejemplo retrocedo 5 commits y existe una rama creada 3 commits atrás, esta rama no tendrá ahora un commit de inicio, no se le podrá identificar de donde vino, lo cual es problemático. Es por este motivo que este comando reset debe utilizarse con mucho cuidado o cuando se está trabajando con una sola rama o cuando se sabe bien lo que hace y las implicancias del los resultados. Un comando mucho más seguro en estos casos sería 'revert'.
    </div>

revert
    <div>
    Crea un nuevo commit que contiene el estado de un commit previo al actual sin borrar el actual. Aunque este nuevo commit contiene el mismo estado de los archivos que el commit al que se está refiriendo, no es el mismo, ya que incluso tiene otro hash.
    revert es por tanto, un comando que ofrece un camino más seguro a la hora de 'deshacer' cambios comparado con el comando reset por ejemplo, ya que no cambia el historial de commits que ya hayan sido subidos al repositorio.
    Para ejecutar este comando hay que agregarle el hash del commit al cual se quiere igualar el estado, una vez ejecutado, pedirá un mensaje como si se estuviera haciendo un commit común.
    Ejemplo. Revertir el estado del repositorio al commit 17a5135:
    $ git revert 17a5135
    </div>

branch
    <div>
    Para crear ramas nuevas en el repositorio o ver las que actualmente existen, borrar ramas.
    Ejemplo. Para ver (listar) las rammas que actualmente existen:
    $ git branch
    La rama en la que se está trabajando (actual) tiene un * al inicio
    Ejemplo. Crear una rama con el nombre version-JavaScript:
    $ git branch version-JavaScript
    Luego será necesario cambiar el HEAD hacia esa rama para trabajar sobre ella.
    ¿La rama version-JavaScript será creada sobre el último commit? ¿Qué pasa con los posibles avances o cambios que se hayan hecho luego del último commit?
    
    -m
        para cambiar el nombre de una rama. hay 2 formas de cambiar el nombre a una rama:
        1° Indicando sólo el nuevo nombre. De esta forma necesario que la rama a la que se desea cambiar nombre sea la rama actual.
        Ejemplo. Cambiar de nombre a la rama actual a "version-js":
        $ git branch -m version-js
        2° Indicando el nombre antiguo y el nuevo nombre de la rama a cambiar. De esta forma no es necesario estar en la rama a la que renombrar.
        Ejemplo. Cambiar el nombre de la rama "version-JavaScript" a "version-js":
        $ git branch -m version-JavaScript version-js
    -d
        Para borrar una rama. Esto aplica para repositorios locales, no en las ramas que ya están publicadas en Github. Si la eliminación fue exitosa, Git muestra un mensaje confirmando la eliminación de la rama. La rama main (o principal) no se puede eliminar, tampoco se puede borrar la rama actual, debemos estar en otra rama para poder borrarla.
        Ejemplo. Borrar la rama "version-py":
        $ git branch -d version-py
    
    -a
        visualiza todas las ramas disponibles en el repositorio incluidas las ramas remotas las cuales empiezan con 'remotes/origin' para denotar su estado remoto e indicar su presencia en un serivdor remoto:
        $ git branch -a
        * main
        remotes/origin/HEAD -> origin/main
        remotes/origin/feature-x
        remotes/origin/feature-y
        remotes/origin/release-1.0
        Este comando es muy importante dado que si se desea ser parte de un proyecto, el chequeo de las ramas siempre debe ser el primer paso.
    </div>

checkout
    <div>
    para cambiar de rama actual (puede ser una versión remota incluso), o regresar a una  versión de commit anterior, o para crear una nueva rama y cambiar a esa rama como actual, o para revertir los cambios de un archivo ...
    checkout puede operar sobre archivos, commits y ramas.
    Para cambiar de rama (funcionaría igual que el comando switch) sólo hay que indicar el nombre de la rama
    Ejemplo. Cambiar a la rama version-JavaScript:
    $ git checkout version-JavaScript
    Cuando se ejecuta este comando, Git muestra el mensaje: Switched to branch ... indicando el cambio a la rama indicada.
    Para cambiar de commit sólo hay que indicar el hash del commit en cuestión
    Ejmplo. Cambiar al commit cd1aff7
    $ git checkout cd1aff7
    Si se desea regresar un número específico de commits desde el HEAD o desde una rama (el último commit de ella) se debe indicar la cantidad de commits precedido del símbolo ~
    Ejemplo. Regresar 2 commits desde el HEAD:
    $ git checkout HEAD~2
    Ejemplo. Regresar 3 commits desde la rama 'desarrollo' (desde el último commit de esta rama):
    $ git checkout desarrollo~3
    
    -b
        crea una rama nueva y mover el HEAD hacia esa nueva rama.
        Ejemplo. Crear y cambiar a una rama llamada version-Python
        $ git checkout -b version-Python
    
    origin/main
        Cambia al repositorio REMOTO origin y a su rama main pero para trabajar de manera local. En este caso se muestra un msg que se puede hacer cambios en local que no van a modificar la información en el remoto. Es muy útil ya que si se trabaja con VS Code, se puede los cambios realizados en el repositorio retomo pero en la máquina local.
        Para que funcione adecuadamente, es necesario antes haber hecho un 'fetch' ya que sino la máquina local no sabrá qué cambios existen en el repositorio remoto, y si luego se necesita regresar a una rama local, main por ejemplo, se ejecuta el comando git switch main.
    <nombre de archivo> o . (punto)
        Se puede usar checkout con el nombre de un archivo para deshacer los cambios que se ha hecho en ese archivo. Esto revertirá el archivo a la versión HEAD.
        Ejemplo. Eliminar (revertir) los cambios realizados desde el último commit en el archivo index.html
        $ git checkout index.html
        Updated 1 path from index
        Si se tiene varios archivos a los que se requiere deshacer los cambios, al igual que con el comando add, se puede usar un punto ( . ) en vez de los nombres de los archivos:
        $ git checkout .
        Updated n paths from the index
    <hash>
        regresa a un commit anterior, para ello hay q indicar el hash del commit al que se desea regresar o parte del hash.
        Ejemplo. Ir al commit con el hash cd5f8b9:
        $ git checkout cd5f8b9
        En este momento, git informa de la situación en la que se ha entrado (en modo detached HEAD, es decir, el HEAD no está apuntando al último commit de una rama), por lo tanto, podrás hacer los cambios que quieras sin que haya problema con las ramas anteriormente establecidas en el git checkout. Ahora, si en este momento quieres deshacer los cambios que has realizado, podrás utilizar la instrucción git switch – y, si quieres guardar los cambios que hayas hecho, puedes introducir la instrucción git switch -c <new-branch-name>.
        Notar que con este comando, si hay cambios que NO se han agregado a un repositorio, estos cambios pueden perderse (pueden ser sobreesctitos por el checkout). Git informa de esta situación en vez de ejecutar el comando. El mensaje que muestra es como este:
        $ git checkout cd5f8b9
        error: Your local changes to the following files would be overwritten by checkout:
            index.html
        Please commit your changes or stash them before you switch branches.
        Aborting
        Será necesario entonces realizar un commit para que todos nuestros cambios estén seguros
    </div>

restore        
    <div>
    devuelve un archivo al estado de un commit previo el cual puede ser el más reciente o algun otro, también sirve para remover archivos del área de preparación.
    IMPORTANTE: En el caso de ejecutar este comando desde el último commit de una rama y además se tiene avanzado cambios sobre ese último commit (que obviamente no se han comiteado) se perderán definitivamente estos últimos cambios y peor aún, los efectos de este comando no se pueden deshacer ya que los cambios, se supone, nunca han sido comiteados por tanto no han sido versionados ni guardados, por tanto se perderán definitivamente.
    Ejemplo. Restaurar el archivo 'myfile.txt' a su versión del último commit:
    $ git restore myfile
    ¿en este caso funciona como el comando checkout?
    Tecnicamente hablando, restore devolverá el archivo a la versión HEAD, la cual tipicamente apunta al último commit de la rama, pero debido a que se puede apuntar el HEAD a cualquier commit, podemos restaurar un archivo a cualquier commit previo, dándonos mucha flexibilidad a la hora de querer restaurar un archivo a cualquier estado. Para restaurar un archivo a un commit antecesor al actual se debe espeficar el número de commits hacia atrás desde el HEAD actual, el commit actual no cuenta (sería como el 0), se empieza a contar 1 desde el commit anterior. Si en ese momento se desea regresar a la versión del HEAD hay que indicar 0 como número de commits hacia atrás.
    Ejemplo. Restaurar el archivo 'file.txt' hacia 3 commits previos al presente HEAD:
    $ git restore --source HEAD~3 file.txt
    Ejemplo. Restaurar a la versión del HEAD (commit 0) el archivo file.txt
    & git restore --source HEAD~0 file.txt
    Este comando también sirve para remover archivos del área de preparación.
    Ejemplo. Remover el archivo file.txt del área de stage:
    $ git restore --staged file.txt
    Tener en cuenta que este comando NO desplaza el HEAD a otra ubicación como lo hace el comando checkout, sino que un archivo es llevado a una versión anterior, el HEAD sigue estando donde estaba antes de ejecutar este comando.
    </div>

merge
    <div>
    para fusionar ramas. Se debe estar en la rama que recibirá la fusión. Notar que mientras se está haciendo la fusión, el mensaje de Git sobre la rama actual muestra también la palabra MERGING: (main|MERGING)
    Ejemplo. Fusionar la rama "version-js" con la rama actual:
    $ git merge version-js
    ¿Qué es fast-forward merge?
    Es la forma más simple de fusionar ramas, se produce cuando por ejemplo sobre la rama main, se ha creado otra rama por ejemplo llamada 'version02', se ha avanzado algunos commits sobre esta última rama mientras que no se ha avanzado nada sobre la rama main, en este caso una fusión con la rama main será muy simple ya que la fusión sólo se trata de acutalizar la main con los commits avanzados en la rama 'version02'. En estos casos git nos indica con un mensaje este tipo de merge que estamos realizando, por ejemplo nos mostraría un mensaje así:
    Updating 9cd41ce..f0f439c
    Fast-forward
    myfile.txt | 4 +++-
    1 file changed, 3 insertions(+), 1 deletion(-)
    Cuando hay conflictos en una unión primero se deben resolver los conflictos, luego utilizar --continue, luego add para llevar los cambios a stage y luego un commit. Ese es el proceso para terminar con un merge con conflictos. Sino, se puede usar --abort para descartar el merge.
    --continue
        Cuando una fusión de ramas tiene conflictos, primero hay que solucionar esos conflictos y luego continuar el proceso de fusión con este comando. Cuamdo se ejecuta este comando los conflictos deben estar solucionados ya que serán subidos al repositorio como un nuevo commit, en VS Code se abre una pestaña nueva esperando confirmar el mensaje de descripción y cerrar el archivo para terminar con la fusión y el commit automático. Al terminar la fusión Git muestra un msg indicando lo correspondiente.
        En el siguiente texto se ha unido la rama 'version-js' a la rama main:
        HP@HPV MINGW64 ~/ruta-reposistorio (main|MERGING)
        $ git merge --continue
        [main 34fd113] Merge branch 'version-js'
    
    --abort
        resetea la sitaución del merge, devolviendo a estao previo antes del merge / pull
    </div>

clone   
    <div>
    Crea una copia local de un repositorio remoto. Este repositorio remoto está alojado en GitHub y ahí hay que obtener la dirección HTTPS de clonación del repositorio para agregarla como argumento a este comando. Hay que tener en cuenta que git crea el repositorio en la carpeta que actualmente se está trabajando, por tanto ante de ejecutar este comando hay que asegurarse estar en la carpeta adecuada. Git mostrará unos mensajes del proceso indicando que el proceso ha sido realizado al 100%
    Ejemplo. Clonar el repositorio de GitHub 'nuevo-proyecto':
    $ git clone https://github.com/usuario/nuevo-proyecto.git
    En este caso la dirección htts ha sido obtenida del repositorio en la web de GitHub.
    Pero ocurre algo al querer enviar los cambios de vuelta al repositorio remoto, en este caso solo hemos hecho una copia en local. Si intentamos hacer git push tendremos un error ya que no hemos definido ningún origen remoto para este directorio. Para guardar en forma remota (usando GitHub) debemos crear un repositorio, conectarlo a nuestra carpeta local con 'git remote add origin ruta' y de esa forma estaremos habilitados para guardar los cambios en remoto.
    Notar que 'clone' sólo hace un clon de la rama principal del repositorio remoto y el resto de ramas no se clonan al local.
    Para clonar un repositorio con todas sus ramas:
        https://www.baeldung.com/ops/git-clone-remote-branches
        https://www.geeksforgeeks.org/how-to-clone-all-remote-branches-in-git/
    Para ver las ramas remotas (que existen en el repositorio remoto en GitHub) ejecutar 'git branch -a'.
    </div>

remote
    <div>
    Crea, ve y elimina conexiones a otros repositorios que más que links directos son como bookmarks.
    Para ver los repositorios remotos que actualmente tienen conexión con la pc local o para establecer esa conexión con los repositorios remotos, estas conexiones se realiza a través de la URL del repositorio, y para no estar tecleando siempre esa URL se puede poner un nombre a esa conexión, normalmente la primera conxión en una sesión de trabajo se le suele llamar por convención 'origin', las siguientes conexiones con otros repositorios en la misma sesión de trabajo deberán tener otros nombres. También sirve para renombrar y eliminar conexiones con repositorios remotos.
    Si se ha clonado un repositorio se debería ver al menos 'origin' que es el nombre que le da GitHub por defecto al servidor del que has clonado, además de la URL que GitHub le da al repositorio.
    El nombre que se le da a una conexión NO es el nombre del repositorio real cuando se creó y no lo sustiruirá, es sólo un nombre temporal para trabajar con el repositorio local y remotamente a la vez.
    Una vez que se establece una conexión con un repositorio remoto, se puede utilizar por ejemplo el comando 'push' para subir nuestros cambios al repositorio remoto o 'pull' para bajar cambios a nuestra pc.
    Si no hay repositorios remotos configurados, este comando no mostrará nada.
    Ejemplo. Mostrar las conextiones que actualmente se tienen configuradas:
    $ git remote
    Aquí se mostrará los nombres de las conexiones que se tengan configuradas. Si no hay conexiones configuradas este comando no mostrará nada.

    -v
        muestra las direcciones del repositorio origen para push (enviar cambios) y fetch (visualizar cambios). Nommalmente serán la misma dirección para ambos. Este comando no muestra ninguna info si no hay respositorios conectados. Utilizar add para agregar repositorios remotos antes de utilizar este comando.
    
    add
        Añade una conexión de un repositorio remoto al repositorio local para poder actualizar cambios u otras cosas. Este comando no crea commits ni sube archivos ni hace nada de ello, Lo único que hace es crear la conexión, para ello hay que indicar un nombre para conexión y una dirección o link del repositorio remoto. La idea es añadir un repositorio y asociarlo a un nombre que luego se pueda referenciar fácilmente, normalmente este nombre es 'origin' por convención para cuando se trabaja con un solo repositorio, pero si se desea agregar más, se debe utilizar otros nombres, luego puedes usar ese nombre en línea de comandos en lugar de la dirección URL entera.
        Después de este comando se puede utilizar -v para ver las direcciones de estos remotos.
        Ejemplo. Agregar un repositorio remoto de nombre 'origin':
        $ git remote add origin https://github.com/usuario/.....git
        Ejemplo. Agregar un repositorio remoto de nombre 'opcion2':
        $ git remote add opcion2 https://github.com/usuario/.....git
    rename <oldname> <newname>
        para renombrar un repositorio remoto
    remove / rm <name> 
        para eliminar la conexion con un repositorio remoto.
    </div>

push
    <div>
    Envía los cambios realizados en un repositorio local a un repositorio remoto para que ambos tengan la misma información y estén sincronizados. Es necesario que exista una conexión entre el repositorio local y el remoto la cual se puede configurar o verificar con el comando 'remote'
    ¿push hace un commit???
    Ejemplo. Enviar datos desde un repositorio local a la rama main de un repositorio remoto:
    $ git push origin main
    Ejemplo. Enviar datos desde un repositorio local a la rama nueva-rama de un repositorio remoto:
    $ git push origin nueva-rama
    En este caso si la rama en remoto no existe, se crea automáticamente.
    -u
    </div>

pull
    <div>
    Descarga el contenido de un repositorio remoto e inmediatamente actualiza un repositorio local para que ambos tengan la misma información si no hay conflictos. A diferencia del comando fetch, pull combina los cambios automáticamente.
    Si no hay cambios en el remoto, este comando no hace nada. No es necesario luego usar otro comando como fetch. Lo que si puede ser necesario es utiliar el comando log para ver los nuevos commits traídos a local
    Ejemplo. Para actualizar un repositorio local desde uno remoto origni (verificar este nombre con git remote -v) hacia nuestra rama main:
    $ git pull origin main
    </div>

fetch
    <div>
    Verifica si se han realizado cambios en el repositorio remoto desde la última vez que actualizaste tu respositorio local con git pull, sin combinar esos cambios con el repositorio local y nos permite ver como una vista previa de esos cambios y luego podemos elegir si queremos conbinarlos o no con el comando merge. Se diferencia del comando pull que sí combina los cambios.
    Ejemplos:
    $ git fetch
    $ git fetch origin <branch>
    $ git fetch <remote> <branch>
    Algo que es común hacer es que luego de hacer un fetch, hacer un git checkout origin/main para desde local en el repositorio remoto sin que los archivos del área de trabajo se vean modificados, esto se puede hacer en VS Code muy intuitivamente.
    
    </div>

switch
    <div>
    para cambiar el HEAD a otra rama, básicamente cambiar de rama de trabajo.
    -c
        para crear una nueva rama y cambiar hacia ella. Git muestra un mensaje sobre el cambio del HEAD hacia la nueva rama creada.
        Ejemplo. Crear la nueva rama 'lanzamiento' y cambiar hacia ella:
        $ git switch -c lanzamiento
        Switched to a new branch 'lanzamiento'
    </div>

diff
    <div>
    compara dos elementos para ver la diferencia. Se puede usar sobre archivos o ramas, también muestra la diferencia entre los cambios que se han realizado desde el último commit.
    Ejemplo. Ver la diferencia entre el último commit y lo avanzado desde ahi:
    $ gid diff
    aquí git muestra información sobre las diferencias...
    Ejemplo. Suponiendo que se está en la rama 'main', compararla con la rama 'login'
    $ git diff login
    </div>

tag
    <div>
    
    </div>

stash
    <div>
    almacena temporalmente los cambios de una rama para poder cambiar a otra rama, trabajar en esta última y luego poder regresar al stash y seguir trabajando sobre ese estado. stash guarda temporalmente el estado de los archivos sin hacer commits. stash es últil en situaciones en que se está trabajando en una rama digamos 'rama-trabajo' se ha avanzado cambios ahí y se desea cambiar temporalmente a otra rama, a main por ejemplo, para hacer algo rápido o pequeño, terminar eso y regresar a la rama 'rama-trabajo' para seguir trabajando donde se dejo el avance, sin hacer ningún commit en 'rama-trabajo' durante todo este proceso. También es útil cuando se necesita aplicar el mismo avance o cambios a múltiples ramas usando el flag apply.
    Por defecto, Git no guarda en el stash los cambios hechos en archivos que no se les está haciendo reastreo (archivos untracked) o archivos ignorados (con .ignore).

    list
        para ver lo que se tiene en los stash. Se muestra todos los stash con información almacenada. Si no hay información en stash, este comando no devuelve nada.
    pop
        recupera lo que hay almacenado en el stash para seguir trabajando normalmente y elimina lo que hay en el stash (elimina el stash) de modo que ya no se puede volver a referenciar.

    apply
        recupera lo que hay almacenado en el stash para seguir trabajando normalmente pero NO elimina lo que hay en el stash (no elimina el stash), pudiendo volver a tener opción de recuperar en otro momento lo que hay en el stash. También es útil cuando se necesita aplicar el mismo avance o cambios a múltiples ramas.
        Sería como una versión más segura de pop ya que no elimina la info.

    drop
        elimina la información del stash sin recuperarla.
    </div>

    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
</div>

<h2>PROCESOS</h2>
<div>

    ## PARA CREAR UN REPOSITORIO LOCAL (VACÍO)
    
    1.  Abrir la git bash
    2.  Situarse en la carpeta deseada que luego contendrá la carpeta .git que definirá la creación de un repositorio
    3.  Usar el comando init:
        git init
    4.  Listo. la carpeta .git debe haberse creado y se debe mostrar la ruta terminando en '(main)', lo que indica que se está en la rama main del repositorio nuevo.
    
    Tener en cuenta que este proceso NO crea un commit, hay que hacerlo con el comando git commit, lo que será el primer commit del repositorio, a diferencia de crear un repositorio nuevo desde GitHub que automáticamente te crea un commit cuando creas un repositorio nuevo.
    
    
    ## PARA CREAR UN REPOSITORIO LOCAL Y ENVIARLO LUEGO A REMOTO (GITHUB)
    ENVIAR!!
    
    1.  Tener o crear un repositorio local (con gitbash) que será el que se subirá. Este repositorio es el que tiene los archivos y commits que se desean subir.
    2.  ¿Tener? o crear un nuevo repositorio remoto (en GitHub) que será el que recibirá el repositorio local. No es necesario que éstos dos repositorios tengan el mismo nombre.
    3.  dar visibilidad al repositorio remoto en gitbash. Ejecutar el comando remote con add y la ruta https del repositorio remoto creado en el paso 2:
        git remote add origin https://github.com/usuario/repositorio.git
    4.  Enviar la info del repositorio local al repositorio remoto con push (a la rama main del origin):
        git push origin main
    5.  Gitbash muestra un msg indicando que entre otras cosas, que se ha creado la rama main en el repositorio remoto nuevo creado en el paso 2. Además en VS Code también se empezarán a sincronizar los cambios.
    
    ## BIFURCAR (FORK) UN REPOSITORIO
    hay que ir al repositorio que se le quiere hacer el fork y hacer clic en el botón 'fork' listo. El repositorio se bifurcado en tu cuenta de GitHub.
    
    ## PARA COMBINAR 2 REPOSITORIOS
    Fuente: https://gist.github.com/msrose/2feacb303035d11d2d05

    ## PARA ELIMINAR UNO O VARIOS COMMITS PREVIOS
    fuente: https://adictosaltrabajo.com/2023/01/05/como-eliminar-commits-de-la-rama-master/
    Si lo que se desea es eliminar una cantidad X de commits exactamente previos al actual (HEAD), utilizar el comando reset, es simple. Pero si se desea eliminar algún(os) commit(s) que están más atrás en el historial sin tocar los que exactamente preceden al actual se debe seguir los siguientes pasos:
    1.  Se desea eliminar los commits del 2 al 4. Obtener la lista de hash de los commits con git log --oneline. Obtendríamos algo así:
        22dcc79 (HEAD -> main, origin/main, origin/HEAD) commit 5
        d53c00f commit 4
        2c3d41d commit 3
        a323615 commit 2
        ecb7ef3 commit 1
        7ed9c6e creacion de repositorio
        Podemos identificar que los commits a eliminar son d53c00f, 2c3d41d y a323615 (del 2 al 4).
    2.  ejecutamos el comando rebase teniendo en cuenta que se debe retroceder hasta un commit previo a los que se quiere eliminar, en este caso retroceder hasta el comit 1 (ecb7ef3), lo que haría una cantidad de 4 commits a retroceder:
        $ git rebase -i HEAD~4
        Se nos mostrará un archivo nuevo un mensaje con los commits elegidos y una leyenda. Lo que hay que hacer es que delante de los commits a eliminar hay que cambiar la palabra 'pick' por 'drop', también se puede borrar las líneas de esos commits, funciona igual, también se eliminarán esos commits.
    3.  Guardar y cerar este archivo. Listo. Ya se puede hacer push si se desea
        $ git push origin +main
        Prestar especial atención al «+» delante de la rama «main». Este caracter está indicando a git que fuerce el push a dicha rama. Si no se pone git se quejará y no podréis pushear el cambio. Una vez pusheado, comprobar cómo en el historial de commits han desaparecido los commits en cuestión.

    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
        
</div>

COMANDOS GENÉRICOS DE LA LÍNEA DE COMANDOS
<div>
cd
    para cambiar directorio. 
    Cuando sólo se escribe cd nos lleva al directorio raíz
cd .. 
    para subir un directorio
cd "ruta"
    para ir a la ruta especificada. Se debe especificar comillas cuando la ruta contiene espacios en blanco

clear
    limpia la pantalla

ls
    para listar archivos y carpetas dentro de la carpeta actual. Las carpetas se diferencian de los archivos por que terminan en /

mkdir
    Make dir. Para crear un directorio

rmdir
    Remove dir. Para eliminar directorios

touch
    para crear archivos en la ruta actual
    Ejemplo. Crear el archivo 'index.html' en la carpeta actual:
    $ touch index.html
    Ejemplo. Crear los archivos 'style.css' y 'script.js':
    $ touch style.css script.js

    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------
    -------------------------------------------------------------------------------
    *******************************************************************************
    -------------------------------------------------------------------------------

</div>